game = false
function KILLRETURN()
  error "not in roblox please execute inside of roblox to continue this script!"
  end
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
if not game then do 
  KILLRETURN()
  end end
----------------------------------------------------------------------------
--rayfield /\
----------------------------------------------------------------------------
if game.PlaceId == 18687417158 then
end
-- Greet the local player
local Players = game:GetService("Players")
    local TextChatService = game:GetService("TextChatService")
    
-- Define the LocalPlayer right away so we can use their name
local localPlayer = Players.LocalPlayer 
    local RBXGeneral = TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXGeneral")
    
-- 1. Greet the local player who is running the script
if localPlayer then
    RBXGeneral:DisplaySystemMessage(string.format("Heyyy!!, %s! Your ShockCatStudio v1.035 UI is Ready!!", localPlayer.DisplayName))
end
---------------------------------------------------------------------------------------------------------------
local Window = Rayfield:CreateWindow({
      Name                 = "ShockCatStudios V4",
       Icon                 = "paw-print", -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
        LoadingTitle         = "ShockCS  presents!",
         LoadingSubtitle      = "by IamSkitten",
          ShowText             = " "..localPlayer.DisplayName .."'s Ui", -- for mobile users to unhide rayfield, change if you'd like
           Theme                = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes
            ToggleUIKeybind      = "P", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)
             DisableRayfieldPrompts = false,
              DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface
               ConfigurationSaving  = {
                Enabled           = true,
                 FolderName        = "CatSSIsprettygoodtbh1", -- Create a custom folder for your hub/game
                  FileName          = "CatSSIsprettygoodHub1"                                      },
                   Discord           = {
                    Enabled           = false, -- Prompt the user to join your Discord server if their executor supports it
                     Invite            = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
                       RememberJoins     = true --[[ Set this to false to make them join the discord every time they load it up ]] },
                        KeySystem = false, -- Set this to true to use our key system
                         KeySettings = {
                          Title    = " This is  " ..localPlayer.DisplayName .. "'s Key system . . .",
                           Subtitle = "Key System",
                            Note     = " "..localPlayer.DisplayName .." Your key is 1234 please type it in below!", -- Use this to tell the user how to get a key
                             FileName = "Key_$k1tt3nistheownerof$h0ckC4t$tudi0s", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
                              SaveKey  = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
                               GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
                                Key      =   {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})
----------------------------------------------------------------------------
--Window Maker(s)
---------------------------------------------------------------------------- 
local Tab01   =    MainWindow:CreateTab  ("NAN"             ,          "app-window-mac") -- Title, Image
local Tab02   =    MainWindow:CreateTab  ("Nan"             ,                 "annoyed") -- Title, Image
local Tab03   =    MainWindow:CreateTab  ("Nan"             ,          'chevrons-right')
local Tab04   =    MainWindow:CreateTab  ("Nan"             ,                "scan-eye")
local Tab05   =    MainWindow:CreateTab  ("Nan"             ,                'workflow')
local Tab06   =    MainWindow:CreateTab  ("Nan"             ,          'laptop-minimal')
local Tab07   =    MainWindow:CreateTab  ("Nan"             ,            'shield-alert')
local Tab08   =    MainWindow:CreateTab  ("Nan"             ,  'gallery-horizontal-end')
local Tab09   =    MainWindow:CreateTab  ("Nan"             ,              'settings-2')
local Tab10   =    MainWindow:CreateTab  ("Nan"             ,                     'cog')
local Tab11   =    MainWindow:CreateTab  ("Nan"             ,                     'cog')
local Tab12   =    MainWindow:CreateTab  ("Nan"             ,                     "cog")
local Tab13   =    MainWindow:CreateTab  ("Nan"             ,                    "bolt")
local Tab14   =    MainWindow:CreateTab  ("Nan"             ,                     "cog")
local Tab15   =    MainWindow:CreateTab  ("Nan"             ,                     "cog")
local Tab16   =    MainWindow:CreateTab  ("Nan"             ,                     "cog") -- Title, Image
local Tab17   =    MainWindow:CreateTab  ("Nan"             ,                     "cog") -- Title, Image
local Tab18   =    MainWindow:CreateTab  ("Nan"             ,                     "cog") -- Title, Image
local Tab19   =    MainWindow:CreateTab  ("Nan"             ,                     "cog")
local Tab21   =    MainWindow:CreateTab  ("Nan"             ,                     "cog") -- Title, Image
local Tab22   =    MainWindow:CreateTab  ("nan"             ,                     "cog")
local Tab23   =    MainWindow:CreateTab  ("UshouldNonseethis"             ,                     "cog") -- Title, Image
local Tab     =    Tab23

----------------------------------------------------------------------------
--Tabs /\ 15
---------------------------------------------------------------------------
--   ArtistShedletsky button (normal) \/
----------------------------------------------------------------------------
local sammyissocool = 'https://raw.githubusercontent.com/ParallaxCube/ShockCatstudios-V1/61efe209da5743e89f9bad065c8b1ecfefd12f21/Artshed'

local Button = Tab11:CreateButton({--misc tab
   Name = "Artist Shedletsky",
   Callback = function()
   -- The function that takes place when the button is pressed
        loadstring(game:HttpGet(sammyissocool))()  -- Executes the code from GitHub
  -- The function that takes place when the button is pressed
   end,
})
local function meep()
  loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/locals%20starting%20heere'))()
end
meep()
----------------------------------------------------------------------------
--   ArtistShedletsky button (normal) /\
----------------------------------------------------------------------------

----------------------------------------------------------------------------
--   Gen Gui Spawner (normal) \/
----------------------------------------------------------------------------
local Button = Tab12:CreateButton({--gen tab
   Name = "Spawns GenGui",
   Callback = function()
   -- The function that takes place when the button is pressed
        loadstring(game:HttpGet(  'https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/GenSpawnButton' ))()  -- Executes the code from GitHub
  -- The function that takes place when the button is pressed
   end,
})
----------------------------------------------------------------------------
--   Gen Gui Spawner (normal) /\
----------------------------------------------------------------------------

----------------------------------------------------------------------------
--   (normal) \/  spoofer                                                         
----------------------------------------------------------------------------
local Button = Tab11:CreateButton({
   Name = "Spoofer",
   Callback = function()
   -- The function that takes place when the button is pressed
        loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/Spoof'))()  -- Executes the code from GitHub
  -- The function that takes place when the button is pressed
   end,
})
----------------------------------------------------------------------------
--  (normal) /\  Spoofer                                                          
----------------------------------------------------------------------------

----------------------------------------------------------------------------
--   (normal) \/    Lag Challange                                                       
----------------------------------------------------------------------------
local Button = Tab11:CreateButton({
   Name = "Lag Challange (Memory leak)",
   Callback = function()
   -- The function that takes place when the button is pressed
        loadstring(game:HttpGet(' https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/laggy  '))()  -- Executes the code from GitHub
  -- The function that takes place when the button is pressed
   end,
})
----------------------------------------------------------------------------
--  (normal) /\     Lag Challange                                                          
----------------------------------------------------------------------------

----------------------------------------------------------------------------
--   (normal) \/   Auto farm                                                        
----------------------------------------------------------------------------
local Button = Tab12:CreateButton({
   Name = "Untested auto farm",
   Callback = function()
   -- The function that takes place when the button is pressed
        loadstring(game:HttpGet('  https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/0c729e63175b330c47a26c66847aa69b161b0908/auto%20farm%20untested '))()  -- Executes the code from GitHub
  -- The function that takes place when the button is pressed
   end,
})
----------------------------------------------------------------------------
--  (normal) /\                                                            
----------------------------------------------------------------------------

----------------------------------------------------------------------------
--\/ Fblock
----------------------------------------------------------------------------
-- Create Tab and Section for FakeBlock functionality


-- Function to play the Fake Block Animations
local function playFakeBlockAnimation(animId)
    local char = localPlayer.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local anim = Instance.new("Animation")
            anim.AnimationId = "rbxassetid://" .. animId
            local track = humanoid:LoadAnimation(anim)
            track:Play()
        end
    end
end

-- Buttons for each animation mode
FEBETab:CreateButton({
    Name = "Fake Block (Normal)",
    Callback = function()
        playFakeBlockAnimation("72722244508749") -- Normal animation ID
    end
})

FEBETab:CreateButton({
    Name = "Fake Block (M3&4)",
    Callback = function()
        playFakeBlockAnimation("96959123077498") -- M3&4 animation ID
    end
})

FEBETab:CreateButton({
    Name = "Toggle Fake Block GUI",
    Callback = function()
        -- This will toggle the visibility of the Rayfield UI
        Rayfield:ToggleUI()
    end
})
----------------------------------------------------------------------------
--FAKE BLOCK /\
----------------------------------------------------------------------------

----------------------------------------------------------------------------
--   (normal) \/   ESP                                                    
----------------------------------------------------------------------------
local Button = Tab11:CreateButton({
   Name = "Button Example",
   Callback = function()
   -- The function that takes place when the button is pressed
   loadstring(game:HttpGet('raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/Esp%20BAD'))()
   -- The function that takes place when the button is pressed
   end,
})
----------------------------------------------------------------------------
--   (normal) /\   ESP                                                    
----------------------------------------------------------------------------



local Button = Tab11:CreateButton({
   Name = "Speed (Both)",
   Callback = function()
   -- The function that takes place when the button is pressed
        local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
        sprintingModule.StaminaGain = tonumber(Input) or 21.5
   -- The function that takes place when the button is pressed
   end,
})

local Button =  Tab11:CreateButton({
   Name = "Stamina Gain (s)",
   Callback = function()
   -- The function that takes place when the button is pressed
           local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
        sprintingModule.SprintSpeed = tonumber(Input) or 26.5
   -- The function that takes place when the button is pressed
   end,
})

----------------------------------------------------------------------------
--   (normal) \/   Auto farm                                                        
----------------------------------------------------------------------------
local Button = Tab12:CreateButton({
   Name = "Button Example",
   Callback = function()
   -- The function that takes place when the button is pressed
        loadstring(game:HttpGet("https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/0c729e63175b330c47a26c66847aa69b161b0908/auto%20farm%20untested"))()  -- Executes the code from GitHub end)
  -- The function that takes place when the button is pressed
   end,
})
----------------------------------------------------------------------------
--  (normal) /\                                                            
----------------------------------------------------------------------------


--// FULL Rayfield UI Skeleton (All Tabs)
--// Safe placeholders only — paste your real exploit code into the marked CALLBACK areas later.
--// This file intentionally DOES NOT create a Rayfield Window. It assumes you already have:
--// local Window = <your existing Rayfield window>
--// and will be inserted into that environment.

local function B(tab, name, fn) tab:CreateButton({Name = name, Callback = fn}) end
local function T(tab, name, init, flag, fn) tab:CreateToggle({Name = name, CurrentValue = init, Flag = flag, Callback = fn}) end
local function S(tab, name, minmax, inc, suf, init, flag, fn) tab:CreateSlider({Name = name, Range = minmax, Increment = inc, Suffix = suf, CurrentValue = init, Flag = flag, Callback = fn}) end
local function I(tab, name, placeholder, fn) tab:CreateInput({Name = name, PlaceholderText = placeholder, Callback = fn}) end

assert(Window, "Window global not found. Assign your Rayfield Window to a variable named 'Window' before running this.")

-- 1) f (app-window-mac)
local Tab_f = Window:CreateTab("f (app-window-mac)")
local Sec_f_core = Tab_f:CreateSection("General")
B(Tab_f, "Open Dev Tools", function()
    -- CALLBACK: paste your code for developer/open tools here
    print("Open Dev Tools pressed")
    -- Example: prompt user to press F9 for Roblox dev console
end)

-- 2) localPlayer.DisplayName (annoyed)
local Tab_name = Window:CreateTab("localPlayer.DisplayName")
local Sec_name = Tab_name:CreateSection("Profile")
I(Tab_name, "Set Display Name", "Enter new display name", function(val)
    -- CALLBACK: handle displayname spoofing / UI
    local success, err = pcall(function()
        local lp = game:GetService("Players").LocalPlayer
        if lp and val and val ~= "" then
            -- This is only local spoofing; server does not change real name
            lp.DisplayName = val
        end
    end)
    if not success then
        print("DisplayName spoof failed:", err)
    else
        print("DisplayName set to:", val)
    end
end)

-- 3) Main (box)
local Tab_Main = Window:CreateTab("Main")
local Sec_Main_core = Tab_Main:CreateSection("Core Features")
B(Tab_Main, "God Mode", function()
    -- CALLBACK: god mode logic here
    local plr = game:GetService("Players").LocalPlayer
    local char = plr.Character or plr.CharacterAdded:Wait()
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.HealthChanged:Connect(function(hp)
            if hp < 1 then
                humanoid.Health = humanoid.MaxHealth
                print("God mode prevented death")
            end
        end)
        print("God Mode enabled")
    end
end)
T(Tab_Main, "Invisibility", false, "Main_Invis", function(v)
    -- CALLBACK: toggle invisibility
    local plr = game:GetService("Players").LocalPlayer
    local char = plr.Character
    if char then
        for _, part in pairs(char:GetChildren()) do
            if part:IsA("BasePart") then
                part.Transparency = v and 1 or 0
                local decal = part:FindFirstChildOfClass("Decal")
                if decal then decal.Transparency = v and 1 or 0 end
            elseif part:IsA("Accessory") then
                local handle = part:FindFirstChild("Handle")
                if handle then handle.Transparency = v and 1 or 0 end
            end
        end
        print("Invisibility toggled:", v)
    end
end)

-- 4) Stamina (chevrons-right)
local Tab_Stamina = Window:CreateTab("Stamina")
local Sec_Stamina = Tab_Stamina:CreateSection("Movement")
B(Tab_Stamina, "Infinite Stamina", function()
    -- CALLBACK: infinite stamina example
    local plr = game:GetService("Players").LocalPlayer
    local staminaStat = plr:FindFirstChild("Stamina") or plr:WaitForChild("Stamina", 5)
    if staminaStat then
        staminaStat.Value = staminaStat.MaxValue or 100
        staminaStat.Changed:Connect(function()
            staminaStat.Value = staminaStat.MaxValue or 100
        end)
        print("Infinite stamina activated")
    else
        print("Stamina stat not found!")
    end
end)
S(Tab_Stamina, "WalkSpeed", {16, 200}, 1, "speed", 26, "WalkSpeedFlag", function(val)
    -- CALLBACK: set walkspeed
    local plr = game:GetService("Players").LocalPlayer
    local char = plr.Character or plr.CharacterAdded:Wait()
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = val
        print("WalkSpeed set to", val)
    end
end)

-- 5) EspTab (scan-eye)
local Tab_ESP = Window:CreateTab("ESP")
local Sec_ESP_players = Tab_ESP:CreateSection("Players & Items")
T(Tab_ESP, "Player ESP", false, "ESP_Players", function(v)
    print("Player ESP toggled:", v)
    -- Example: toggle ESP highlights on all players
end)
T(Tab_ESP, "Killer ESP", false, "ESP_Killer", function(v)
    print("Killer ESP toggled:", v)
    -- Example: toggle killer highlights
end)
T(Tab_ESP, "Item ESP", false, "ESP_Items", function(v)
    print("Item ESP toggled:", v)
    -- Example: toggle item highlights
end)

-- 6) ACTab (workflow)
local Tab_AC = Window:CreateTab("ACTab")
local Sec_AC = Tab_AC:CreateSection("Automation & Cheats")
B(Tab_AC, "Auto-Collect Items", function()
    print("Auto-Collect triggered")
    -- Example: loop through collectibles and fire server calls
end)
T(Tab_AC, "Auto Solve Generator", false, "AutoSolveGen", function(v)
    print("Auto Solve Generator toggled:", v)
    -- Example: start/stop generator solving routine
end)

-- 7) DeviceTab (laptop-minimal)
local Tab_Device = Window:CreateTab("DeviceTab")
local Sec_Device = Tab_Device:CreateSection("Device Settings")
T(Tab_Device, "Low Graphics", false, "LowGraphics", function(v)
    if v then
        game:GetService("Lighting").GlobalShadows = false
        game:GetService("Lighting").FogEnd = 100000
        print("Low graphics enabled")
    else
        game:GetService("Lighting").GlobalShadows = true
        game:GetService("Lighting").FogEnd = 1000
        print("Low graphics disabled")
    end
end)

-- 8) StunTab (shield-alert)
local Tab_Stun = Window:CreateTab("StunTab")
local Sec_Stun = Tab_Stun:CreateSection("Defensive")
B(Tab_Stun, "God + Stun Protection", function()
    print("Stun protection enabled")
    -- Example: hook stun events and cancel or prevent them
end)

-- 9) SavefileTab (gallery-horizontal-end)
local Tab_Save = Window:CreateTab("Savefile")
local Sec_Save = Tab_Save:CreateSection("Save & Load")
B(Tab_Save, "Save Settings", function()
    local flags = Window:SaveFlags()
    print("Settings saved:", flags)
end)
B(Tab_Save, "Load Settings", function()
    Window:LoadFlags()
    print("Settings loaded")
end)

-- 10) StatsTab (settings-2)
local Tab_Stats = Window:CreateTab("StatsTab")
local Sec_Stats = Tab_Stats:CreateSection("Player Stats")
I(Tab_Stats, "Set Health", "Enter HP value", function(val)
    local hp = tonumber(val)
    if not hp then
        print("Invalid HP value")
        return
    end
    local plr = game:GetService("Players").LocalPlayer
    local char = plr.Character or plr.CharacterAdded:Wait()
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Health = math.clamp(hp, 0, humanoid.MaxHealth)
        print("Set health to:", humanoid.Health)
    end
end)

-- 11) MTab (cog)
local Tab_M = Window:CreateTab("MTab")
local Sec_M = Tab_M:CreateSection("Misc")
B(Tab_M, "Toggle FOV", function()
    local cam = workspace.CurrentCamera
    if cam.FieldOfView == 70 then
        cam.FieldOfView = 120
        print("FOV set to 120")
    else
        cam.FieldOfView = 70
        print("FOV reset to 70")
    end
end)

-- 12) GenTab (microchip)
local Tab_Gen = Window:CreateTab("GenTab")
local Sec_Gen = Tab_Gen:CreateSection("Generators")
T(Tab_Gen, "Auto Solve Generators", false, "GenAutoSolve", function(v)
    print("Auto Solve Generators toggled:", v)
    -- Add generator solving logic here
end)
B(Tab_Gen, "Teleport To Generator", function()
    local plr = game:GetService("Players").LocalPlayer
    local char = plr.Character or plr.CharacterAdded:Wait()
    local genContainer = workspace:FindFirstChild("Generators") -- Example container
    if genContainer then
        local nearest
        local nearestDist = math.huge
        for _, g in pairs(genContainer:GetChildren()) do
            if g:IsA("BasePart") then
                local dist = (char.HumanoidRootPart.Position - g.Position).Magnitude
                if dist < nearestDist then
                    nearest = g
                    nearestDist = dist
                end
            end
        end
        if nearest then
            char.HumanoidRootPart.CFrame = nearest.CFrame + Vector3.new(0,3,0)
            print("Teleported to generator")
        else
            print("No generator found")
        end
    else
        print("Generators container not found")
    end
end)

-- 13) ExTab (bolt)
local Tab_Ex = Window:CreateTab("ExTab")
local Sec_Ex = Tab_Ex:CreateSection("Extras & Fun")
B(Tab_Ex, "Lag Challenge", function()
    for i = 1, 500 do        local p = Instance.new("Part")
        p.Size = Vector3.new(1,1,1)
        p.Position = workspace.CurrentCamera.CFrame.Position + Vector3.new(math.random(-50,50), math.random(-50,50), math.random(-50,50))
        p.Anchored = true
        p.Parent = workspace
    end
    print("Lag challenge started")
end)
B(Tab_Ex, "Random Server TP", function()
    print("Teleporting to random server (placeholder)")
    -- Your server hop code here
end)

-- 14) StupidTab (microchip)
local Tab_Stupid = Window:CreateTab("StupidTab")
local Sec_Stupid = Tab_Stupid:CreateSection("Weird Stuff")
B(Tab_Stupid, "Do Nothing Button", function()
    print("You pressed the do-nothing button. Congrats.")
end)

-- Optional: helper to register a quick notification function
local function notify(msg)
    if typeof(game) ~= "Instance" then return end
    pcall(function()
        if game:GetService("StarterGui"):FindFirstChild("SetCore") then
            game:GetService("StarterGui"):SetCore("SendNotification", {Title = "Rayfield", Text = msg, Duration = 3})
        end
    end)
end

-- End of skeleton
-- Paste your modules inside CALLBACK blocks or replace print(...) lines with loadstring/require calls.
-------------------------------------------------------------------------------------------------------------------------------







---------------------------------------------------------------------------
--Fixer upper in german start
---------------------------------------------------------------------------
local Section = Tab8:CreateSection("player")

local Button = Tab:CreateButton({
   Name = "invisible (beta)",
   Callback = function()
   local Players = game:GetService("Players")

local function setInvisible(player)
    local character = player.Character
    if not character then return end

    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            part.Transparency = 1  -- Полностью прозрачный
            part.CanCollide = false -- Нет столкновений
        elseif part:IsA("Decal") or part:IsA("Texture") then
            part.Transparency = 1
        end
    end
end
local function setVisible(player)
    local character = player.Character
    if not character then return end
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            part.Transparency = 0
            part.CanCollide = true
        elseif part:IsA("Decal") or part:IsA("Texture") then
            part.Transparency = 0
        end
    end
end

-- Пример вызова:
local player = Players.LocalPlayer  -- Для локального скрипта
setInvisible(player)
-- Чтобы вернуть видимость, вызови:
-- setVisible(player)
   end,
})

local Button = Tab:CreateButton({
   Name = "god mode (beta)",
   Callback = function()
   local Players = game:GetService("Players")

local function enableGodMode(player)
    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        -- Отключаем урон через событие HealthChanged
        humanoid.HealthChanged:Connect(function(health)
            if health < humanoid.MaxHealth then
                humanoid.Health = humanoid.MaxHealth
            end
        end)
    end
end

-- Пример вызова:
local player = Players.LocalPlayer  -- Для локального скрипта
enableGodMode(player)
   end,
})

local Tab = Window:CreateTab("Esp", "rewind")
local Section = Tab:CreateSection("Esp killers, Esp players")

local Button = Tab:CreateButton({
   Name = "Esp killer",
   Callback = function()
   -- Список целей
local killers = {
    "c00lkidd",
    "JohnDoe",
    "Jason",
    "1x1x1x1",
    "Noli"
}

-- Функция добавления ESP
local function addESP(part)
    if part:FindFirstChild("Highlight") then return end -- уже есть ESP

    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 0, 0) -- цвет заливки
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255) -- цвет контура
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0.2
    highlight.Adornee = part
    highlight.Parent = part
end

-- Авто-обновление каждые 0.5 сек
while task.wait(0.5) do
    for _, killerName in ipairs(killers) do
        local path = game:GetService("Workspace"):FindFirstChild("Players")
        if path and path:FindFirstChild("Killers") then
            local killer = path.Killers:FindFirstChild(killerName)
            if killer and killer:FindFirstChild("QueryHitbox") then
                addESP(killer.QueryHitbox)
            end
        end
    end
end
   end,
})

local Button = Tab:CreateButton({
   Name = "Esp Players",
   Callback = function()
   -- Цвет ESP
local ESP_COLOR = Color3.fromRGB(0, 170, 255) -- голубой

-- Функция для подсветки
local function addHighlight(part)
    if not part:FindFirstChild("Highlight") then
        local hl = Instance.new("Highlight")
        hl.FillColor = ESP_COLOR
        hl.OutlineColor = Color3.fromRGB(255, 110, 255)
        hl.FillTransparency = 0.5
        hl.OutlineTransparency = 0
        hl.Adornee = part
        hl.Parent = part
    end
end

-- Функция для имени и дистанции
local function addBillboard(part, name)
    if not part:FindFirstChild("ESPName") then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESPName"
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.AlwaysOnTop = true
        billboard.StudsOffset = Vector3.new(0, 2, 0)
        billboard.Parent = part

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        textLabel.TextStrokeTransparency = 0
        textLabel.Font = Enum.Font.GothamBold
        textLabel.TextSize = 14
        textLabel.Parent = billboard

        -- Обновление дистанции
        task.spawn(function()
            while billboard.Parent do
                local distance = math.floor((workspace.CurrentCamera.CFrame.Position - part.Position).Magnitude)
                textLabel.Text = name .. " [" .. distance .. "m]"
                task.wait(0.2)
            end
        end)
    end
end

-- Главный цикл ESP
task.spawn(function()
    while task.wait(0.5) do
        for _, plr in ipairs(game.Players:GetPlayers()) do
            if plr ~= game.Players.LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                addHighlight(plr.Character.HumanoidRootPart)
                addBillboard(plr.Character.HumanoidRootPart, plr.Name)
            end
        end
    end
end)
   end,
})

local Button = Tab:CreateButton({
   Name = "Esp generators",
   Callback = function()
   local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")

local mapFolder = workspace.Map.Ingame.Map

-- Создаем ESP для каждого объекта в папке
for _, obj in pairs(mapFolder:GetChildren()) do
    if obj:IsA("BasePart") then
        local billboard = Instance.new("BillboardGui")
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.AlwaysOnTop = true
        billboard.Adornee = obj
        billboard.Parent = obj

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.new(1, 0, 0)
        textLabel.TextScaled = true
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.Parent = billboard

        runService.RenderStepped:Connect(function()
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - obj.Position).Magnitude
                textLabel.Text = string.format("Generator / %d m", math.floor(distance))
            end
        end)
    end
end
   end,
})

local Tab = Window:CreateTab("Afk", "rewind")
local Section = Tab:CreateSection("Afk teleport, afk platform")

local Button = Tab:CreateButton({
   Name = "Afk Teleport",
   Callback = function()
   -- Список имён киллеров
local killers = {
    "c00lkidd",
    "JohnDoe",
    "Jason",
    "1x1x1x1",
    "Noli"
}

-- Порог срабатывания в студсах
local TRIGGER_DISTANCE = 15

-- Куда телепортировать (примерная безопасная позиция)
local SAFE_POSITION = Vector3.new(1000, 100, 1000) -- поменяй на свою

-- Функция проверки
local function checkKillers()
    local lp = game.Players.LocalPlayer
    if not (lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")) then return end
    local myPos = lp.Character.HumanoidRootPart.Position

    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, name in ipairs(killers) do
            local killer = killersFolder:FindFirstChild(name)
            if killer and killer:FindFirstChild("QueryHitbox") then
                local distance = (killer.QueryHitbox.Position - myPos).Magnitude
                if distance <= TRIGGER_DISTANCE then
                    -- Телепортируем игрока
                    lp.Character.HumanoidRootPart.CFrame = CFrame.new(SAFE_POSITION)
                    print("Телепорт из-за близости киллера:", name)
                    break
                end
            end
        end
    end
end

-- Запуск цикла проверки
task.spawn(function()
    while task.wait(0.1) do
        checkKillers()
    end
end)
   end,
})

local Tab = Window:CreateTab("hitbox", "rewind")
local Section = Tab:CreateSection("hitbox players, hitbox killer")

local Button = Tab:CreateButton({
   Name = "hitbox players",
   Callback = function()
   -- Множитель размера
local SIZE_MULTIPLIER = 5

-- Функция увеличения хитбоксов
local function enlargeHitbox(character)
    if character and character:FindFirstChild("HumanoidRootPart") then
        local hrp = character.HumanoidRootPart
        hrp.Size = Vector3.new(2, 2, 1) * SIZE_MULTIPLIER
        hrp.Transparency = 0.7 -- чтобы видеть размер (можно убрать)
        hrp.BrickColor = BrickColor.new("Really red") -- цвет для наглядности
        hrp.Material = Enum.Material.Neon
        hrp.CanCollide = false
    end
end

-- Автообновление
task.spawn(function()
    while task.wait(0.5) do
        for _, plr in ipairs(game.Players:GetPlayers()) do
            if plr ~= game.Players.LocalPlayer and plr.Character then
                enlargeHitbox(plr.Character)
            end
        end
    end
end)
   end,
})

local Button = Tab:CreateButton({
   Name = "hitbox killer",
   Callback = function()
   -- Список имён киллеров
local killers = {
    "c00lkidd",
    "JohnDoe",
    "Jason",
    "1x1x1x1",
    "Noli"
}

-- Множитель размера
local SIZE_MULTIPLIER = 5

-- Функция увеличения хитбоксов
local function enlargeHitbox(model)
    if model and model:FindFirstChild("HumanoidRootPart") then
        local hrp = model.HumanoidRootPart
        hrp.Size = Vector3.new(2, 2, 1) * SIZE_MULTIPLIER
        hrp.Transparency = 0.7 -- для наглядности, можно убрать
        hrp.BrickColor = BrickColor.new("Really red")
        hrp.Material = Enum.Material.Neon
        hrp.CanCollide = false
    end
end

-- Автообновление
task.spawn(function()
    while task.wait(0.5) do
        local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
        if killersFolder then
            for _, name in ipairs(killers) do
                local killer = killersFolder:FindFirstChild(name)
                if killer then
                    enlargeHitbox(killer)
                end
            end
        end
    end
end)
   end,
})

local Tab = Window:CreateTab("teleport", "rewind")
local Section = Tab:CreateSection("teleport")

local Button = Tab:CreateButton({
   Name = "teleport to player",
   Callback = function()
   local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Создание GUI
local screenGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
screenGui.Name = "TPMenu"

local frame = Instance.new("Frame", screenGui)
frame.Size = UDim2.new(0, 300, 0, 200)
frame.Position = UDim2.new(0.5, -150, 0.5, -100)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0

-- Выбранный игрок
local selectedPlayer = nil

-- Список игроков
local uiList = Instance.new("UIListLayout", frame)
uiList.SortOrder = Enum.SortOrder.LayoutOrder

-- Заголовок
local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, 0, 0, 30)
title.Text = "Выбери игрока:"
title.TextColor3 = Color3.new(1, 1, 1)
title.BackgroundTransparency = 1
title.Font = Enum.Font.SourceSansBold
title.TextSize = 20

-- Кнопки игроков
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        local btn = Instance.new("TextButton", frame)
        btn.Size = UDim2.new(1, 0, 0, 30)
        btn.Text = player.Name
        btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.Font = Enum.Font.SourceSans
        btn.TextSize = 18

        btn.MouseButton1Click:Connect(function()
            selectedPlayer = player
            -- Подсветка выбора
            for _, otherBtn in pairs(frame:GetChildren()) do
                if otherBtn:IsA("TextButton") then
                    otherBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                end
            end
            btn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        end)
    end
end

-- Кнопка "ТП"
local tpButton = Instance.new("TextButton", frame)
tpButton.Size = UDim2.new(1, 0, 0, 30)
tpButton.Text = "Телепортироваться"
tpButton.BackgroundColor3 = Color3.fromRGB(70, 120, 70)
tpButton.TextColor3 = Color3.new(1, 1, 1)
tpButton.Font = Enum.Font.SourceSansBold
tpButton.TextSize = 18

tpButton.MouseButton1Click:Connect(function()
    if selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = selectedPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(2, 0, 0)
        end
    end
    screenGui:Destroy() -- Удалить меню после ТП
end)
   end,
})

local Tab = Window:CreateTab("Credits", "rewind")
local Section = Tab:CreateSection("Credits")

local Button = Tab:CreateButton({
   Name = "gogslo2111 = Robanik = создатель",
   Callback = function()
   -- The function that takes place when the button is pressed
   end,
})

local Button = Tab:CreateButton({
   Name = "random_beast5 = Sombrita_games = тестер",
   Callback = function()
   -- The function that takes place when the button is pressed
   end,
})

---------------------------------------------------------------------------
--Fixer upper in german end
---------------------------------------------------------------------------
---------------------------------------------------------------------------
--alot of stuff exploits mostly esp and stam as ive seen
---------------------------------------------------------------------------

local Toggle = PlayerTab:CreateToggle({
   Name = "Infinite Stamina",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       if Value then
           local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
           
           local originalStaminaChange = sprintingModule.ChangeStat
           sprintingModule.ChangeStat = function(self, stat, value)
               if stat == "Stamina" then
                   return
               end
               return originalStaminaChange(self, stat, value)
           end
           
           local originalInit = sprintingModule.Init
           sprintingModule.Init = function(self)
               originalInit(self)
               
               self.StaminaLossDisabled = true
               self.Stamina = self.MaxStamina
               
               local staminaLoop
               staminaLoop = game:GetService("RunService").Heartbeat:Connect(function()
                   if self.Stamina < self.MaxStamina then
                       self.Stamina = self.MaxStamina
                       if self.__staminaChangedEvent then
                           self.__staminaChangedEvent:Fire(self.MaxStamina)
                       end
                   end
               end)
               
               self._infiniteStaminaLoop = staminaLoop
           end
           
           if sprintingModule.DefaultsSet then
               sprintingModule.StaminaLossDisabled = true
               sprintingModule.Stamina = sprintingModule.MaxStamina
               
               if not sprintingModule._infiniteStaminaLoop then
                   local staminaLoop = game:GetService("RunService").Heartbeat:Connect(function()
                       if sprintingModule.Stamina < sprintingModule.MaxStamina then
                           sprintingModule.Stamina = sprintingModule.MaxStamina
                           if sprintingModule.__staminaChangedEvent then
                               sprintingModule.__staminaChangedEvent:Fire(sprintingModule.MaxStamina)
                           end
                       end
                   end)
                   sprintingModule._infiniteStaminaLoop = staminaLoop
               end
           end
           
           _G.InfiniteStaminaData = {
               OriginalChangeStat = originalStaminaChange,
               OriginalInit = originalInit,
               Module = sprintingModule
           }
           
       else
           if _G.InfiniteStaminaData then
               local sprintingModule = _G.InfiniteStaminaData.Module
               
               sprintingModule.ChangeStat = _G.InfiniteStaminaData.OriginalChangeStat
               sprintingModule.Init = _G.InfiniteStaminaData.OriginalInit
               sprintingModule.StaminaLossDisabled = false
               
               if sprintingModule._infiniteStaminaLoop then
                   sprintingModule._infiniteStaminaLoop:Disconnect()
                   sprintingModule._infiniteStaminaLoop = nil
               end
               
               _G.InfiniteStaminaData = nil
           end
       end
   end,
})
local Input = PlayerTab:CreateInput({
   Name = "Speed",
   CurrentValue = "",
   PlaceholderText = "Enter sprint speed",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
       local newSpeed = tonumber(Text)
       if newSpeed then
           local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
           
           if sprintingModule then
               sprintingModule.SprintSpeed = newSpeed
               
               if sprintingModule.IsSprinting and sprintingModule.__speedMultiplier then
                   local humanoid = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
                   if humanoid then
                       local baseSpeed = humanoid:GetAttribute("BaseSpeed") or 16
                       sprintingModule.__speedMultiplier.Value = newSpeed / baseSpeed
                   end
               end
           end
       end
   end,
})
local Input = PlayerTab:CreateInput({
   Name = "Stamina gain/sec",
   CurrentValue = "",
   PlaceholderText = "Enter stamina gain per second",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
       local newGain = tonumber(Text)
       if newGain then
           local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
           
           if sprintingModule then
               sprintingModule.StaminaGain = newGain
           end
       end
   end,
})
local Toggle = EspTab:CreateToggle({
   Name = "Killer esp",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       if Value then
           if not _G.KillerESPData then
               _G.KillerESPData = {
                   Highlights = {},
                   Connections = {}
               }
           end

           local function isKiller(model)
               return model:IsA("Model") and model.Parent and model.Parent.Name == "Killers" and model.Parent.Parent and model.Parent.Parent.Name == "Players" and model.Parent.Parent.Parent == game.Workspace
           end

           local function updateKillerESP()
               for killer, highlight in pairs(_G.KillerESPData.Highlights) do
                   if killer and killer.Parent then
                       highlight.Adornee = killer
                       highlight.Enabled = true
                   else
                       highlight.Enabled = false
                   end
               end
           end

           local function createKillerESP(killer)
               if not isKiller(killer) then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = killer.Name .. "_KillerESP"
               highlight.FillColor = Color3.fromRGB(255, 0, 0)
               highlight.FillTransparency = 0.5
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               _G.KillerESPData.Highlights[killer] = highlight
           end

           local function scanForKillers()
               local playersFolder = game.Workspace:FindFirstChild("Players")
               if playersFolder then
                   local killersFolder = playersFolder:FindFirstChild("Killers")
                   if killersFolder then
                       for _, killer in pairs(killersFolder:GetChildren()) do
                           if killer:IsA("Model") then
                               createKillerESP(killer)
                           end
                       end
                   end
               end
           end

           scanForKillers()

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Killers" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Players" and grandParent.Parent == game.Workspace then
                           createKillerESP(descendant)
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.KillerESPData.Highlights[descendant] then
                   _G.KillerESPData.Highlights[descendant]:Destroy()
                   _G.KillerESPData.Highlights[descendant] = nil
               end
           end

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(handleDescendantAdded)
           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.KillerESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.KillerESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateKillerESP()
           end)

       else
           if _G.KillerESPData then
               if _G.KillerESPData.UpdateLoop then
                   _G.KillerESPData.UpdateLoop:Disconnect()
               end

               if _G.KillerESPData.MainConnections then
                   _G.KillerESPData.MainConnections.descendantAdded:Disconnect()
                   _G.KillerESPData.MainConnections.descendantRemoving:Disconnect()
               end

               for killer, highlight in pairs(_G.KillerESPData.Highlights) do
                   highlight:Destroy()
               end

               _G.KillerESPData = nil
           end
       end
   end,
})
local Toggle = EspTab:CreateToggle({
   Name = "Players' esp",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       if Value then
           if not _G.SurvivorESPData then
               _G.SurvivorESPData = {
                   Highlights = {},
                   Connections = {}
               }
           end

           local function isSurvivor(model)
               return model:IsA("Model") and model.Parent and model.Parent.Name == "Survivors" and model.Parent.Parent and model.Parent.Parent.Name == "Players" and model.Parent.Parent.Parent == game.Workspace and model ~= game.Players.LocalPlayer.Character
           end

           local function updateSurvivorESP()
               for survivor, highlight in pairs(_G.SurvivorESPData.Highlights) do
                   if survivor and survivor.Parent then
                       highlight.Adornee = survivor
                       highlight.Enabled = true
                   else
                       highlight.Enabled = false
                   end
               end
           end

           local function createSurvivorESP(survivor)
               if not isSurvivor(survivor) then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = survivor.Name .. "_SurvivorESP"
               highlight.FillColor = Color3.fromRGB(0, 255, 0)
               highlight.FillTransparency = 0.6
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               _G.SurvivorESPData.Highlights[survivor] = highlight
           end

           local function scanForSurvivors()
               local playersFolder = game.Workspace:FindFirstChild("Players")
               if playersFolder then
                   local survivorsFolder = playersFolder:FindFirstChild("Survivors")
                   if survivorsFolder then
                       for _, survivor in pairs(survivorsFolder:GetChildren()) do
                           if survivor:IsA("Model") then
                               createSurvivorESP(survivor)
                           end
                       end
                   end
               end
           end

           scanForSurvivors()

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Survivors" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Players" and grandParent.Parent == game.Workspace then
                           createSurvivorESP(descendant)
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.SurvivorESPData.Highlights[descendant] then
                   _G.SurvivorESPData.Highlights[descendant]:Destroy()
                   _G.SurvivorESPData.Highlights[descendant] = nil
               end
           end

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(handleDescendantAdded)
           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.SurvivorESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.SurvivorESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateSurvivorESP()
           end)

       else
           if _G.SurvivorESPData then
               if _G.SurvivorESPData.UpdateLoop then
                   _G.SurvivorESPData.UpdateLoop:Disconnect()
               end

               if _G.SurvivorESPData.MainConnections then
                   _G.SurvivorESPData.MainConnections.descendantAdded:Disconnect()
                   _G.SurvivorESPData.MainConnections.descendantRemoving:Disconnect()
               end

               for survivor, highlight in pairs(_G.SurvivorESPData.Highlights) do
                   highlight:Destroy()
               end

               _G.SurvivorESPData = nil
           end
       end
   end,
})
local Toggle = EspTab:CreateToggle({
   Name = "Item esp",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       if Value then
           if not _G.ItemESPData then
               _G.ItemESPData = {
                   Highlights = {},
                   Billboards = {},
                   Connections = {}
               }
           end

           local function isTargetItem(model)
               return model:IsA("Model") and (model.Name == "BloxyCola" or model.Name == "Medkit") and 
                      model.Parent and model.Parent.Name == "Map" and 
                      model.Parent.Parent and model.Parent.Parent.Name == "Ingame" and 
                      model.Parent.Parent.Parent and model.Parent.Parent.Parent.Name == "Map" and 
                      model.Parent.Parent.Parent.Parent == game.Workspace
           end

           local function updateItemESP()
               for item, data in pairs(_G.ItemESPData.Highlights) do
                   if item and item.Parent then
                       data.highlight.Adornee = item
                       data.highlight.Enabled = true
                       if data.billboard then
                           data.billboard.Adornee = item
                           data.billboard.Enabled = true
                       end
                   else
                       data.highlight.Enabled = false
                       if data.billboard then
                           data.billboard.Enabled = false
                       end
                   end
               end
           end

           local function createItemESP(item)
               if not isTargetItem(item) then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = item.Name .. "_ItemESP"
               highlight.FillColor = Color3.fromRGB(128, 0, 128)
               highlight.FillTransparency = 0.5
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.1
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               local billboard = Instance.new("BillboardGui")
               billboard.Name = item.Name .. "_Label"
               billboard.Size = UDim2.new(0, 80, 0, 20)
               billboard.StudsOffset = Vector3.new(0, 2, 0)
               billboard.AlwaysOnTop = true
               billboard.Adornee = item
               billboard.Parent = game.CoreGui
               
               local textLabel = Instance.new("TextLabel")
               textLabel.Size = UDim2.new(1, 0, 1, 0)
               textLabel.BackgroundTransparency = 1
               textLabel.Text = item.Name
               textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
               textLabel.TextSize = 12
               textLabel.Font = Enum.Font.SourceSansBold
               textLabel.TextStrokeTransparency = 0
               textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
               textLabel.Parent = billboard
               
               _G.ItemESPData.Highlights[item] = {
                   highlight = highlight,
                   billboard = billboard
               }
           end

           local function scanForItems()
               local mapFolder = game.Workspace:FindFirstChild("Map")
               if mapFolder then
                   local ingameFolder = mapFolder:FindFirstChild("Ingame")
                   if ingameFolder then
                       local mapSubFolder = ingameFolder:FindFirstChild("Map")
                       if mapSubFolder then
                           for _, item in pairs(mapSubFolder:GetDescendants()) do
                               if item:IsA("Model") and (item.Name == "BloxyCola" or item.Name == "Medkit") then
                                   createItemESP(item)
                               end
                           end
                       end
                   end
               end
           end

           scanForItems()

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") and (descendant.Name == "BloxyCola" or descendant.Name == "Medkit") then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Map" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Ingame" then
                           local greatGrandParent = grandParent.Parent
                           if greatGrandParent and greatGrandParent.Name == "Map" and greatGrandParent.Parent == game.Workspace then
                               createItemESP(descendant)
                           end
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.ItemESPData.Highlights[descendant] then
                   local data = _G.ItemESPData.Highlights[descendant]
                   data.highlight:Destroy()
                   if data.billboard then
                       data.billboard:Destroy()
                   end
                   _G.ItemESPData.Highlights[descendant] = nil
               end
           end

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(handleDescendantAdded)
           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.ItemESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.ItemESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateItemESP()
           end)

       else
           if _G.ItemESPData then
               if _G.ItemESPData.UpdateLoop then
                   _G.ItemESPData.UpdateLoop:Disconnect()
               end

               if _G.ItemESPData.MainConnections then
                   _G.ItemESPData.MainConnections.descendantAdded:Disconnect()
                   _G.ItemESPData.MainConnections.descendantRemoving:Disconnect()
               end

               for item, data in pairs(_G.ItemESPData.Highlights) do
                   data.highlight:Destroy()
                   if data.billboard then
                       data.billboard:Destroy()
                   end
               end

               _G.ItemESPData = nil
           end
       end
   end,
})
local Toggle = EspTab:CreateToggle({
   Name = "Generators' esp",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       if Value then
           if not _G.GeneratorESPData then
               _G.GeneratorESPData = {
                   Highlights = {},
                   Billboards = {},
                   Connections = {}
               }
           end

           local function isGenerator(model)
               return model:IsA("Model") and model.Name == "Generator" and 
                      model.Parent and model.Parent.Name == "Map" and 
                      model.Parent.Parent and model.Parent.Parent.Name == "Ingame" and 
                      model.Parent.Parent.Parent and model.Parent.Parent.Parent.Name == "Map" and 
                      model.Parent.Parent.Parent.Parent == game.Workspace
           end

           -- Функция для получения прогресса генератора
           local function getGeneratorProgress(generator)
               local progressValue = generator:FindFirstChild("Progress")
               if progressValue and progressValue:IsA("NumberValue") then
                   return progressValue.Value
               end
               return 0
           end

           local function updateGeneratorESP()
               for generator, highlight in pairs(_G.GeneratorESPData.Highlights) do
                   if generator and generator.Parent then
                       local progress = getGeneratorProgress(generator)
                       
                       -- Если прогресс 100% - скрываем подсветку
                       if progress >= 100 then
                           highlight.Enabled = false
                           if _G.GeneratorESPData.Billboards[generator] then
                               _G.GeneratorESPData.Billboards[generator].Enabled = false
                           end
                       else
                           highlight.Enabled = true
                           
                           -- Обновляем цвет в зависимости от прогресса
                           if progress == 0 then
                               highlight.FillColor = Color3.fromRGB(255, 0, 0) -- Красный
                           elseif progress < 50 then
                               highlight.FillColor = Color3.fromRGB(255, 165, 0) -- Оранжевый
                           elseif progress < 100 then
                               highlight.FillColor = Color3.fromRGB(255, 255, 0) -- Желтый
                           end
                           
                           -- Обновляем текст прогресса
                           if _G.GeneratorESPData.Billboards[generator] then
                               _G.GeneratorESPData.Billboards[generator].TextLabel.Text = math.floor(progress) .. "%"
                               _G.GeneratorESPData.Billboards[generator].Enabled = true
                           end
                       end
                       
                       highlight.Adornee = generator
                   else
                       highlight.Enabled = false
                       if _G.GeneratorESPData.Billboards[generator] then
                           _G.GeneratorESPData.Billboards[generator].Enabled = false
                       end
                   end
               end
           end

           local function createGeneratorESP(generator)
               if not isGenerator(generator) then return end
               
               -- Создаем подсветку
               local highlight = Instance.new("Highlight")
               highlight.Name = generator.Name .. "_GeneratorESP"
               highlight.FillColor = Color3.fromRGB(255, 0, 0) -- Начальный цвет красный
               highlight.FillTransparency = 0.6
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               -- Создаем BillboardGui для текста прогресса
               local billboard = Instance.new("BillboardGui")
               billboard.Name = generator.Name .. "_ProgressText"
               billboard.Adornee = generator:FindFirstChild("PrimaryPart") or generator:FindFirstChildWhichIsA("BasePart")
               billboard.Size = UDim2.new(0, 100, 0, 40)
               billboard.StudsOffset = Vector3.new(0, 3, 0)
               billboard.AlwaysOnTop = true
               billboard.MaxDistance = 100
               
               local textLabel = Instance.new("TextLabel")
               textLabel.Size = UDim2.new(1, 0, 1, 0)
               textLabel.BackgroundTransparency = 1
               textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
               textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
               textLabel.TextStrokeTransparency = 0
               textLabel.TextSize = 14
               textLabel.Font = Enum.Font.GothamBold
               textLabel.Text = "0%"
               textLabel.Parent = billboard
               
               billboard.Parent = game.CoreGui
               
               _G.GeneratorESPData.Highlights[generator] = highlight
               _G.GeneratorESPData.Billboards[generator] = billboard
           end

           local function scanForGenerators()
               local mapFolder = game.Workspace:FindFirstChild("Map")
               if mapFolder then
                   local ingameFolder = mapFolder:FindFirstChild("Ingame")
                   if ingameFolder then
                       local mapSubFolder = ingameFolder:FindFirstChild("Map")
                       if mapSubFolder then
                           for _, generator in pairs(mapSubFolder:GetDescendants()) do
                               if generator:IsA("Model") and generator.Name == "Generator" then
                                   createGeneratorESP(generator)
                               end
                           end
                       end
                   end
               end
           end

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") and descendant.Name == "Generator" then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Map" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Ingame" then
                           local greatGrandParent = grandParent.Parent
                           if greatGrandParent and greatGrandParent.Name == "Map" and greatGrandParent.Parent == game.Workspace then
                               createGeneratorESP(descendant)
                           end
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.GeneratorESPData.Highlights[descendant] then
                   _G.GeneratorESPData.Highlights[descendant]:Destroy()
                   _G.GeneratorESPData.Highlights[descendant] = nil
               end
               if _G.GeneratorESPData.Billboards[descendant] then
                   _G.GeneratorESPData.Billboards[descendant]:Destroy()
                   _G.GeneratorESPData.Billboards[descendant] = nil
               end
           end

           -- Соединение для отслеживания изменения прогресса
           local function monitorProgressChanges()
               for generator, _ in pairs(_G.GeneratorESPData.Highlights) do
                   local progressValue = generator:FindFirstChild("Progress")
                   if progressValue and progressValue:IsA("NumberValue") then
                       if not _G.GeneratorESPData.Connections[generator] then
                           _G.GeneratorESPData.Connections[generator] = progressValue:GetPropertyChangedSignal("Value"):Connect(function()
                               updateGeneratorESP()
                           end)
                       end
                   end
               end
           end

           scanForGenerators()
           monitorProgressChanges()

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(function(descendant)
               handleDescendantAdded(descendant)
               task.wait(0.1) -- Ждем немного перед мониторингом прогресса
               monitorProgressChanges()
           end)

           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.GeneratorESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.GeneratorESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateGeneratorESP()
           end)

       else
           -- Отключаем ESP
           if _G.GeneratorESPData then
               if _G.GeneratorESPData.UpdateLoop then
                   _G.GeneratorESPData.UpdateLoop:Disconnect()
               end

               if _G.GeneratorESPData.MainConnections then
                   _G.GeneratorESPData.MainConnections.descendantAdded:Disconnect()
                   _G.GeneratorESPData.MainConnections.descendantRemoving:Disconnect()
               end

               -- Отключаем соединения прогресса
               for generator, connection in pairs(_G.GeneratorESPData.Connections) do
                   connection:Disconnect()
               end

               -- Удаляем подсветки и билборды
               for generator, highlight in pairs(_G.GeneratorESPData.Highlights) do
                   highlight:Destroy()
               end
               for generator, billboard in pairs(_G.GeneratorESPData.Billboards) do
                   billboard:Destroy()
               end

               _G.GeneratorESPData = nil
           end
       end
   end,
})
local Button = MainTab:CreateButton({
   Name = "Fulbright",
   Callback = function()
       local Lighting = game:GetService("Lighting")
       
       -- Сохраняем оригинальные настройки
       if not _G.OriginalLightingSettings then
           _G.OriginalLightingSettings = {
               Ambient = Lighting.Ambient,
               Brightness = Lighting.Brightness,
               ColorShift_Bottom = Lighting.ColorShift_Bottom,
               ColorShift_Top = Lighting.ColorShift_Top,
               EnvironmentDiffuseScale = Lighting.EnvironmentDiffuseScale,
               EnvironmentSpecularScale = Lighting.EnvironmentSpecularScale,
               GlobalShadows = Lighting.GlobalShadows,
               OutdoorAmbient = Lighting.OutdoorAmbient,
               ShadowSoftness = Lighting.ShadowSoftness
           }
       end
       
       -- Устанавливаем Fulbright настройки
       Lighting.Ambient = Color3.fromRGB(255, 255, 255)
       Lighting.Brightness = 2
       Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
       Lighting.ColorShift_Top = Color3.fromRGB(0, 0, 0)
       Lighting.EnvironmentDiffuseScale = 0
       Lighting.EnvironmentSpecularScale = 0
       Lighting.GlobalShadows = false
       Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
       Lighting.ShadowSoftness = 0
       
       -- Отключаем все источники света
       for _, light in pairs(Lighting:GetChildren()) do
           if light:IsA("Light") then
               light.Enabled = false
           end
       end
   end,
})
local Toggle = EspTab:CreateToggle({
   Name = "C00lkid's minions esp",
   CurrentValue = false,
   Flag = "Toggle1",
   Callback = function(Value)
       if Value then
           if not _G.MinionESPData then
               _G.MinionESPData = {
                   Highlights = {},
                   Connections = {}
               }
           end

           local function isMinion(model)
               return model:IsA("Model") and model.Name == "PizzaDeliveryRig" and 
                      model.Parent and model.Parent.Name == "Ingame" and 
                      model.Parent.Parent and model.Parent.Parent.Name == "Map" and 
                      model.Parent.Parent.Parent == game.Workspace
           end

           local function updateMinionESP()
               for minion, highlight in pairs(_G.MinionESPData.Highlights) do
                   if minion and minion.Parent then
                       highlight.Adornee = minion
                       highlight.Enabled = true
                   else
                       highlight.Enabled = false
                   end
               end
           end

           local function createMinionESP(minion)
               if not isMinion(minion) then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = minion.Name .. "_MinionESP"
               highlight.FillColor = Color3.fromRGB(0, 0, 255)
               highlight.FillTransparency = 0.6
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               _G.MinionESPData.Highlights[minion] = highlight
           end

           local function scanForMinions()
               local mapFolder = game.Workspace:FindFirstChild("Map")
               if mapFolder then
                   local ingameFolder = mapFolder:FindFirstChild("Ingame")
                   if ingameFolder then
                       local minion = ingameFolder:FindFirstChild("PizzaDeliveryRig")
                       if minion then
                           createMinionESP(minion)
                       end
                   end
               end
           end

           scanForMinions()

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") and descendant.Name == "PizzaDeliveryRig" then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Ingame" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Map" and grandParent.Parent == game.Workspace then
                           createMinionESP(descendant)
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.MinionESPData.Highlights[descendant] then
                   _G.MinionESPData.Highlights[descendant]:Destroy()
                   _G.MinionESPData.Highlights[descendant] = nil
               end
           end

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(handleDescendantAdded)
           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.MinionESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.MinionESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateMinionESP()
           end)

       else
           if _G.MinionESPData then
               if _G.MinionESPData.UpdateLoop then
                   _G.MinionESPData.UpdateLoop:Disconnect()
               end

               if _G.MinionESPData.MainConnections then
                   _G.MinionESPData.MainConnections.descendantAdded:Disconnect()
                   _G.MinionESPData.MainConnections.descendantRemoving:Disconnect()
               end

               for minion, highlight in pairs(_G.MinionESPData.Highlights) do
                   highlight:Destroy()
               end

               _G.MinionESPData = nil
           end
       end
   end,
})
local AutoGenerator = {
    Enabled = false,
    Cooldown = 2.5,
    Loop = nil
}

-- Объявляем функции ДО тоггла
local function ForceCompletePuzzle()
    local success, FlowGameManager = pcall(function()
        return require(game.ReplicatedStorage.Modules.Misc.FlowGameManager)
    end)
    
    if not success then
        return false
    end
    
    if FlowGameManager.activeGame and not FlowGameManager.activeGame.gameEnded then
        FlowGameManager.activeGame:EndGame(true)
        return true
    end
    
    return false
end

local function FindAndActivateGenerator()
    local IngameMapFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame")
    local SubMapFolder = IngameMapFolder and IngameMapFolder:FindFirstChild("Map")
    
    if not SubMapFolder then return false end
    
    for _, generator in ipairs(SubMapFolder:GetChildren()) do
        if generator.Name == "Generator" then
            local progress = generator:FindFirstChild("Progress")
            if progress and progress:IsA("NumberValue") and progress.Value < 100 then
                local success = pcall(function()
                    generator.Remotes.RE:FireServer()
                end)
                
                if success then
                    print("✅ Generator activated, waiting for puzzle...")
                    
                    local maxWaitTime = 10
                    local startTime = tick()
                    
                    while tick() - startTime < maxWaitTime do
                        task.wait(0.1)
                        
                        if ForceCompletePuzzle() then
                            print("✅ Puzzle completed automatically!")
                            return true
                        end
                    end
                    
                    print("❌ Puzzle didn't appear in time")
                    return false
                end
            end
        end
    end
    
    return false
end

local function StartAutoGenerator()
    if AutoGenerator.Loop then
        AutoGenerator.Loop:Disconnect()
        AutoGenerator.Loop = nil
    end
    
    AutoGenerator.Loop = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
        if not AutoGenerator.Enabled then return end
        
        if not AutoGenerator.LastCheck then
            AutoGenerator.LastCheck = tick()
        end
        
        if tick() - AutoGenerator.LastCheck >= AutoGenerator.Cooldown then
            AutoGenerator.LastCheck = tick()
            
            local success = FindAndActivateGenerator()
            
            if not success then
                print("❌ No available generators found")
            end
        end
    end)
end

local function StopAutoGenerator()
    if AutoGenerator.Loop then
        AutoGenerator.Loop:Disconnect()
        AutoGenerator.Loop = nil
    end
    AutoGenerator.LastCheck = nil
    print("❌ Auto Generator disabled")
end

-- Теперь создаем UI элементы ПОСЛЕ объявления функций
local Slider = GeneratorTab:CreateSlider({
   Name = "Auto Generator time",
   Range = {2.5, 5},
   Increment = 0.1,
   Suffix = "sec",
   CurrentValue = 2.5,
   Flag = "AutoGenTime",
   Callback = function(Value)
       AutoGenerator.Cooldown = Value
   end,
})

local Toggle = GeneratorTab:CreateToggle({
   Name = "Auto Generator",
   CurrentValue = false,
   Flag = "AutoGenToggle",
   Callback = function(Value)
       AutoGenerator.Enabled = Value
       
       if Value then
           StartAutoGenerator()
       else
           StopAutoGenerator()
       end
   end,
})

local Button = GeneratorTab:CreateButton({
   Name = "Complete Current Puzzle",
   Callback = function()
       if ForceCompletePuzzle() then
           print("✅ Current puzzle completed!")
       else
           print("❌ No active puzzle found")
       end
   end,
})
local Aimbot = {
    Enabled = false,
    Connection = nil,
    Active = false,
    Cooldown = 3,
    Prediction = 0.5
}

local function FindPlasmaBeamButton()
    local localPlayer = game.Players.LocalPlayer
    if not localPlayer then return nil end
    
    local playerGui = localPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return nil end
    
    local mainUI = playerGui:FindFirstChild("MainUI")
    if mainUI then
        local abilityContainer = mainUI:FindFirstChild("AbilityContainer")
        if abilityContainer then
            return abilityContainer:FindFirstChild("PlasmaBeam")
        end
    end
    
    return nil
end

local function GetNearestKiller()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return nil end
    
    local camera = workspace.CurrentCamera
    if not camera then return nil end
    
    local nearestKiller = nil
    local nearestDistance = math.huge
    
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") then
            local killerHRP = killer:FindFirstChild("HumanoidRootPart")
            if killerHRP then
                local distance = (camera.CFrame.Position - killerHRP.Position).Magnitude
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestKiller = killer
                end
            end
        end
    end
    
    return nearestKiller
end

local function AimAtKiller()
    local killer = GetNearestKiller()
    if not killer then return false end
    
    local camera = workspace.CurrentCamera
    if not camera then return false end
    
    local killerHRP = killer:FindFirstChild("HumanoidRootPart")
    if not killerHRP then return false end
    
    local currentCFrame = camera.CFrame
    
    -- Простое предсказание движения
    local predictedPosition = killerHRP.Position + killerHRP.Velocity * Aimbot.Prediction
    
    local targetCFrame = CFrame.lookAt(currentCFrame.Position, predictedPosition)
    camera.CFrame = targetCFrame
    
    return true
end

local function SetupPlasmaBeamAimbot()
    if not Aimbot.Enabled then return end
    
    local plasmaBeamButton = FindPlasmaBeamButton()
    if not plasmaBeamButton then
        task.delay(3, SetupPlasmaBeamAimbot)
        return
    end
    
    if plasmaBeamButton:IsA("TextButton") or plasmaBeamButton:IsA("ImageButton") then
        plasmaBeamButton.MouseButton1Click:Connect(function()
            if Aimbot.Enabled and not Aimbot.Active then
                Aimbot.Active = true
                
                if Aimbot.Connection then
                    Aimbot.Connection:Disconnect()
                end
                
                Aimbot.Connection = game:GetService("RunService").Heartbeat:Connect(function()
                    if not Aimbot.Active or not Aimbot.Enabled then return end
                    AimAtKiller()
                end)
                
                task.delay(Aimbot.Cooldown, function()
                    Aimbot.Active = false
                    if Aimbot.Connection then
                        Aimbot.Connection:Disconnect()
                        Aimbot.Connection = nil
                    end
                end)
            end
        end)
    end
end

local Toggle = AimbotTab:CreateToggle({
   Name = "PlasmaBeam Aimbot",
   CurrentValue = false,
   Flag = "PlasmaBeamAimbot",
   Callback = function(Value)
       Aimbot.Enabled = Value
       
       if Value then
           SetupPlasmaBeamAimbot()
       else
           if Aimbot.Connection then
               Aimbot.Connection:Disconnect()
               Aimbot.Connection = nil
           end
           Aimbot.Active = false
       end
   end,
})

local Slider = AimbotTab:CreateSlider({
   Name = "Prediction",
   Range = {0.0, 1.0},
   Increment = 0.1,
   Suffix = "sec",
   CurrentValue = 0.5,
   Flag = "AimbotPrediction",
   Callback = function(Value)
       Aimbot.Prediction = Value
   end,
})

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
    task.wait(3)
    if Aimbot.Enabled then
        SetupPlasmaBeamAimbot()
    end
end)

local ZombieESP = {
    Enabled = false,
    Highlights = {},
    Connections = {}
}

local Toggle = EspTab:CreateToggle({
   Name = "1x4 Zombies Esp",
   CurrentValue = false,
   Flag = "ZombieESP",
   Callback = function(Value)
       ZombieESP.Enabled = Value
       
       if Value then
           -- Включаем ESP
           local function CreateZombieESP(zombie)
               if not zombie:IsA("Model") then return end
               if ZombieESP.Highlights[zombie] then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = "ZombieESP"
               highlight.FillColor = Color3.fromRGB(0, 100, 255) -- Синий цвет
               highlight.FillTransparency = 0.7
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255) -- Белый контур
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Adornee = zombie
               highlight.Parent = game.CoreGui
               
               ZombieESP.Highlights[zombie] = highlight
               
               -- Отслеживаем удаление зомби
               local connection
               connection = zombie.AncestryChanged:Connect(function(_, parent)
                   if not parent then
                       if highlight then
                           highlight:Destroy()
                       end
                       ZombieESP.Highlights[zombie] = nil
                       connection:Disconnect()
                   end
               end)
           end
           
           -- Ищем существующих зомби
           local function ScanForZombies()
               local mapFolder = workspace:FindFirstChild("Map")
               if not mapFolder then return end
               
               local ingameFolder = mapFolder:FindFirstChild("Ingame")
               if not ingameFolder then return end
               
               local zombieFolder = ingameFolder:FindFirstChild("1x1x1x1Zombie")
               if not zombieFolder then return end
               
               for _, zombie in ipairs(zombieFolder:GetDescendants()) do
                   if zombie:IsA("Model") and zombie:FindFirstChild("Humanoid") then
                       CreateZombieESP(zombie)
                   end
               end
           end
           
           -- Отслеживаем новых зомби
           local function MonitorZombieFolder()
               local mapFolder = workspace:FindFirstChild("Map")
               if not mapFolder then return end
               
               local ingameFolder = mapFolder:FindFirstChild("Ingame")
               if not ingameFolder then return end
               
               local zombieFolder = ingameFolder:FindFirstChild("1x1x1x1Zombie")
               if not zombieFolder then return end
               
               ZombieESP.Connections.descendantAdded = zombieFolder.DescendantAdded:Connect(function(descendant)
                   if descendant:IsA("Model") and descendant:FindFirstChild("Humanoid") then
                       task.wait(0.1) -- Ждем полной загрузки модели
                       CreateZombieESP(descendant)
                   end
               end)
               
               ZombieESP.Connections.descendantRemoving = zombieFolder.DescendantRemoving:Connect(function(descendant)
                   if ZombieESP.Highlights[descendant] then
                       ZombieESP.Highlights[descendant]:Destroy()
                       ZombieESP.Highlights[descendant] = nil
                   end
               end)
           end
           
           -- Оптимизированное обновление
           ZombieESP.Connections.updateLoop = game:GetService("RunService").Stepped:Connect(function()
               if not ZombieESP.Enabled then return end
               
               for zombie, highlight in pairs(ZombieESP.Highlights) do
                   if zombie and zombie.Parent then
                       highlight.Enabled = true
                   else
                       highlight.Enabled = false
                   end
               end
           end)
           
           -- Запускаем сканирование
           ScanForZombies()
           MonitorZombieFolder()
           
       else
           -- Выключаем ESP
           for _, connection in pairs(ZombieESP.Connections) do
               connection:Disconnect()
           end
           ZombieESP.Connections = {}
           
           for _, highlight in pairs(ZombieESP.Highlights) do
               highlight:Destroy()
           end
           ZombieESP.Highlights = {}
       end
   end,
})
---------------------------------------------------------------------------
--alot of stuff exploits mostly esp and stam as ive seen end here
---------------------------------------------------------------------------
---------------------------------------------
--broekn stuff i might have to delete or fix below
------------------------------------------------------------------------

local Settings = {
    Stamina = {Enabled = false, Value = 100},
    Speed = {Enabled = false, Value = 16},
    ESP = {Players = false, Killers = true, Generators = true, Items = false},
    AutoRepair = {Enabled = false, Speed = 5, Instant = false}
}

local function ManageStamina()
while Settings.Stamina.Enabled do
task.wait(0.5)
local char = game.Players.LocalPlayer.Character
if char and char:FindFirstChild("Stamina") then
char.Stamina.Value = Settings.Stamina.Value
end
end
end

local function UpdateSpeed()
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Settings.Speed.Enabled and Settings.Speed.Value or 26.5
end

local MainTab = Window:NewTab("Main")
local MainSection = MainTab:NewSection("Character")

MainSection:NewToggle("Infinite Stamina", "", function(state)
    Settings.Stamina.Enabled = state
    ManageStamina()
end)

MainSection:NewSlider("Speed", "", 50, 16, function(value)
    Settings.Speed.Value = value
    UpdateSpeed()
end)

MainSection:NewToggle("Enable Speed", "", function(state)
    Settings.Speed.Enabled = state
    UpdateSpeed()
end)

local ESPTab = Window:NewTab("ESP")
local ESPSection = ESPTab:NewSection("Settings")

ESPSection:NewToggle("Players", "", function(state)
    Settings.ESP.Players = state
end)

ESPSection:NewToggle("Killers", "", function(state)
    Settings.ESP.Killers = state
end)

local AutoTab = Window:NewTab("Automation")
local AutoSection = AutoTab:NewSection("Generators")

AutoSection:NewToggle("Auto-Repair", "", function(state)
    Settings.AutoRepair.Enabled = state
end)

AutoSection:NewSlider("Repair Speed", "", 20, 3, function(value)
    Settings.AutoRepair.Speed = value
end)

AutoSection:NewToggle("Instant Repair", "", function(state)
    Settings.AutoRepair.Instant = state
end)

game:GetService("StarterGui"):SetCore("SendNotification",{
    Title = "Loader",
    Text = "Ready",
    Duration = 3
})


------------------------------------------------------------------------
--end of that stuff i might have to delate or fix idk  lOL
-----------------------------------------------
------------------------------------------------------------------------
--goodeieever start  lOL
-----------------------------------------------

local Settings = {
    Stamina = {Enabled = false, Value = 100},
    Speed = {Enabled = false, Value = 16},
    ESP = {Players = false, Killers = true, Generators = true, Items = false},
    AutoRepair = {Enabled = false, Speed = 5, Instant = false}
}

local function ManageStamina()
while Settings.Stamina.Enabled do
task.wait(0.5)
local char = game.Players.LocalPlayer.Character
if char and char:FindFirstChild("Stamina") then
char.Stamina.Value = Settings.Stamina.Value
end
end
end

local function UpdateSpeed()
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Settings.Speed.Enabled and Settings.Speed.Value or 26.5
end



MainSection:NewToggle("Infinite Stamina", "", function(state)
    Settings.Stamina.Enabled = state
    ManageStamina()
end)

MainSection:NewSlider("Speed", "", 50, 16, function(value)
    Settings.Speed.Value = value
    UpdateSpeed()
end)

MainSection:NewToggle("Enable Speed", "", function(state)
    Settings.Speed.Enabled = state
    UpdateSpeed()
end)

local ESPTab = Window:NewTab("ESP")
local ESPSection = ESPTab:NewSection("Settings")

ESPSection:NewToggle("Players", "", function(state)
    Settings.ESP.Players = state
end)

ESPSection:NewToggle("Killers", "", function(state)
    Settings.ESP.Killers = state
end)

local AutoTab = Window:NewTab("Automation")
local AutoSection = AutoTab:NewSection("Generators")

AutoSection:NewToggle("Auto-Repair", "", function(state)
    Settings.AutoRepair.Enabled = state
end)

AutoSection:NewSlider("Repair Speed", "", 20, 3, function(value)
    Settings.AutoRepair.Speed = value
end)

AutoSection:NewToggle("Instant Repair", "", function(state)
    Settings.AutoRepair.Instant = state
end)

game:GetService("StarterGui"):SetCore("SendNotification",{
    Title = "Loader",
    Text = "Ready",
    Duration = 3
})




------------------------------------------------------------------------
--SO LONG AUTO BLOCK start  lOL
-----------------------------------------------



local Button = Tab:CreateButton({
   Name = "Button Example",
   Callback = function()
   -- The function that takes place when the button is pressed
   loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/ebdc21137d5ee95d59a4b18df14f73df9b2349a3/autoblock1v1'))()
      -- The function that takes place when the button is pressed
   end,
})



local lastReplaceTime = {
    block = 0,
    punch = 0,
    charge = 0,
}
function happhapp()
loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/Moreautoblocl%3F'))()
end
happhapp()
-- Auto block + punch detection loop
RunService.RenderStepped:Connect(function()
    local gui = PlayerGui:FindFirstChild("MainUI")
    local punchBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Punch")
    local charges = punchBtn and punchBtn:FindFirstChild("Charges")
    local blockBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Block")
    local cooldown = blockBtn and blockBtn:FindFirstChild("CooldownTime")

    local myChar = lp.Character
    if not myChar then return end
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    Humanoid = myChar:FindFirstChildOfClass("Humanoid")
        -- Auto Block: Trigger block if a valid animation is played by a killer
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= lp and plr.Character then
            local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
            local hum = plr.Character:FindFirstChildOfClass("Humanoid")
            local animTracks = hum and hum:FindFirstChildOfClass("Animator") and hum:FindFirstChildOfClass("Animator"):GetPlayingAnimationTracks()

            if hrp and myRoot and (hrp.Position - myRoot.Position).Magnitude <= detectionRange then
                for _, track in ipairs(animTracks or {}) do
                    local id = tostring(track.Animation.AnimationId):match("%d+")
                    if table.find(autoBlockTriggerAnims, id) then
                        if autoBlockOn and (hrp.Position - myRoot.Position).Magnitude <= detectionRange then
                            if isFacing(myRoot, hrp) then
                                if cooldown and cooldown.Text == "" then
                                    fireRemoteBlock()
                                end
                                if doubleblocktech == true and charges and charges.Text == "1" then
                                    fireRemotePunch()
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    -- Detect if player is playing a block animation, and blockTP is enabled

    -- Predictive Auto Block: Check killer range and time
    if predictiveBlockOn and tick() > predictiveCooldown then
        local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
        local myChar = lp.Character
        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local myHum = myChar and myChar:FindFirstChild("Humanoid")

        if killersFolder and myHRP and myHum then
            local killerInRange = false

            for _, killer in ipairs(killersFolder:GetChildren()) do
                local hrp = killer:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local dist = (myHRP.Position - hrp.Position).Magnitude
                    if dist <= detectionRange then
                        killerInRange = true
                        break
                    end
                end
            end

            -- Handle killer entering range
            if killerInRange then
                if not killerInRangeSince then
                    killerInRangeSince = tick()  -- Start the timer when the killer enters the range
                elseif tick() - killerInRangeSince >= edgeKillerDelay then
                    -- Block if the killer has stayed in range long enough
                    fireRemoteBlock()
                    predictiveCooldown = tick() + 2  -- Set cooldown to avoid blocking too quickly again
                    killerInRangeSince = nil  -- Reset the timer
                end
            else
                killerInRangeSince = nil  -- Reset timer if the killer leaves range
            end
        end
    end


    local myChar = lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    -- Auto Punch
    if autoPunchOn then
        if charges and charges.Text == "1" then
            
            for _, name in ipairs(killerNames) do
                local killer = workspace:FindFirstChild("Players")
                    and workspace.Players:FindFirstChild("Killers")
                    and workspace.Players.Killers:FindFirstChild(name)
                if killer and killer:FindFirstChild("HumanoidRootPart") then
                    local root = killer.HumanoidRootPart
                    if root and myRoot and (root.Position - myRoot.Position).Magnitude <= 10 then

                        -- Trigger punch GUI button
                        fireGuiPunch()

                        -- Fling Punch: Constant TP 2 studs in front of killer for 1 second
                        if flingPunchOn then
                            hiddenfling = true
                            local targetHRP = root
                            task.spawn(function()
                                local start = tick()
                                while tick() - start < 1 do
                                    if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and targetHRP and targetHRP.Parent then
                                        local frontPos = targetHRP.Position + (targetHRP.CFrame.LookVector * 2)
                                        lp.Character.HumanoidRootPart.CFrame = CFrame.new(frontPos, targetHRP.Position)
                                    end
                                    task.wait()
                                end
                                hiddenfling = false
                            end)
                        end

                        -- Play custom punch animation if enabled
                        if customPunchEnabled and customPunchAnimId ~= "" then
                            playCustomAnim(customPunchAnimId, true)
                        end

                        break -- Only punch one killer per frame
                    end
                end
            end
        end
    end
    -- === Message-When-Punching: send once per animation start ===
    do
        local myChar = lp.Character
        local hum = myChar and myChar:FindFirstChildOfClass("Humanoid")
        local animator = cachedAnimator
        local currentPlaying = {} -- map animId -> true for tracks playing this frame
        if not animator then
            refreshAnimator()
            animator = cachedAnimator
        end
        if animator then
            local ok, tracks = pcall(function() return animator:GetPlayingAnimationTracks() end)
            if ok and tracks then
                for _, track in ipairs(tracks) do
                    local animId
                    pcall(function() animId = tostring(track.Animation and track.Animation.AnimationId or ""):match("%d+") end)
                    if animId and table.find(punchAnimIds, animId) then
                        currentPlaying[animId] = true
    
                        -- if it wasn't playing last frame, it's a newly-started punch animation
                        if not _punchPrevPlaying[animId] then
                            if messageWhenAutoPunchOn and messageWhenAutoPunch and tostring(messageWhenAutoPunch):match("%S") and (tick() - _lastPunchMessageTime) > MESSAGE_PUNCH_COOLDOWN then
                                pcall(function() sendChatMessage(messageWhenAutoPunch) end)
                                _lastPunchMessageTime = tick()
                            end
                        end
                    end
                end
            end
        end

        -- replace prev state with current state (garbage-collected)
        _punchPrevPlaying = currentPlaying
    end

    do
        local myChar = lp.Character
        local hum = myChar and myChar:FindFirstChildOfClass("Humanoid")
        local animator = cachedAnimator
        local currentPlaying = {} -- map animId -> true for tracks playing this frame
        if not animator then
            refreshAnimator()
            animator = cachedAnimator
        end
        if animator then
            local ok, tracks = pcall(function() return animator:GetPlayingAnimationTracks() end)
            if ok and tracks then
                for _, track in ipairs(tracks) do
                    local animId
                    pcall(function() animId = tostring(track.Animation and track.Animation.AnimationId or ""):match("%d+") end)
                    if animId and table.find(blockAnimIds, animId) then
                        currentPlaying[animId] = true
    
                        -- if it wasn't playing last frame, it's a newly-started punch animation
                        if not _blockPrevPlaying[animId] then
                            if messageWhenAutoBlockOn and messageWhenAutoBlock and tostring(messageWhenAutoBlock):match("%S") and (tick() - _lastBlockMessageTime) > MESSAGE_BLOCK_COOLDOWN then
                                pcall(function() sendChatMessage(messageWhenAutoBlock) end)
                                _lastBlockMessageTime = tick()
                            end
                        end
                    end
                end
            end
        end

        -- replace prev state with current state (garbage-collected)
        _blockPrevPlaying = currentPlaying
    end

    -- === end message-when-punching ===
    if aimPunch then
        if not cachedAnimator then
            refreshAnimator()
        end
        local animator = cachedAnimator
        if animator and myRoot and myChar then
            for _, name in ipairs(killerNames) do
                local killer = workspace:FindFirstChild("Players")
                    and workspace.Players:FindFirstChild("Killers")
                    and workspace.Players.Killers:FindFirstChild(name)
                if killer and killer:FindFirstChild("HumanoidRootPart") then
                    local root = killer.HumanoidRootPart

                    for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                        -- guard: want only punch tracks (vanilla or custom)
                        local animId = tostring(track.Animation.AnimationId):match("%d+")
                        if table.find(punchAnimIds, animId) then

                            -- Avoid retriggering for the same AnimationTrack within cooldown
                            local last = lastAimTrigger[track]
                            if last and tick() - last < AIM_COOLDOWN then
                                -- already triggered recently for this track -> skip
                            else
                                -- Only trigger when the track is just starting (helps avoid mid/late triggers)
                                local timePos = 0
                                pcall(function() timePos = track.TimePosition or 0 end) -- safe read
                                if timePos <= 0.1 then
                                    -- Lock it so we don't retrigger
                                    lastAimTrigger[track] = tick()

                                    -- Disable autoroate once and aim for AIM_WINDOW seconds
                                    local humanoid = myChar:FindFirstChild("Humanoid")
                                    if humanoid then
                                        humanoid.AutoRotate = false
                                    end

                                    task.spawn(function()
                                        local start = tick()
                                        while tick() - start < AIM_WINDOW do
                                            if myRoot and root and root.Parent then
                                                local predictedPos = root.Position + (root.CFrame.LookVector * predictionValue)
                                                myRoot.CFrame = CFrame.lookAt(myRoot.Position, predictedPos)
                                            end
                                            task.wait()
                                        end
                                        -- restore
                                        if humanoid then
                                            humanoid.AutoRotate = true
                                        end

                                        -- cleanup: allow retrigger later
                                        task.delay(AIM_COOLDOWN - AIM_WINDOW, function()
                                            lastAimTrigger[track] = nil
                                        end)
                                    end)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end)





------------------------------------------------------------------------
--SO LONG END OF AUTO BLOCK end  lOL
-----------------------------------------------




loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/%3Fan%20extra%20gui'))()







-------------------------------------------------------------------------------------------------------
--end of a whole other code im so done fr
-------------------------------------------------------------------------------------------------------


Rayfield:LoadConfiguration()
meep()
