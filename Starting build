local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

----------------------------------------------------------------------------
-- Rayfield & peanut Protection!! BAHAHHAHA! 
----------------------------------------------------------------------------
-- Greet the local player
local Players = game:GetService("Players")
    local TextChatService = game:GetService("TextChatService")
    
-- Define the LocalPlayer right away so we can use their name
local localPlayer = Players.LocalPlayer 
    local RBXGeneral = TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXGeneral")
    
-- 1. Greet the local player who is running the script
if localPlayer then
    RBXGeneral:DisplaySystemMessage(string.format("Heyyy!!, %s! Your ShockCatStudio v1.035 UI is Ready!!", localPlayer.DisplayName))
end
print ("ShockCatStudio Was Executed for "..localPlayer.DisplayName .."!")
---------------------------------------------------------------------------------------------------------------
local MainWindow = Rayfield:CreateWindow({
      Name                 = "ShockCatStudios 3.4v ",
       Icon                 = "paw-print", -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
        LoadingTitle         = "ShockCS  presents!",
         LoadingSubtitle      = "by IamSkitten",
          ShowText             = " "..localPlayer.DisplayName .."'s Ui", -- for mobile users to unhide rayfield, change if you'd like
           Theme                = "Default", -- Check https://docs.sirius.menu/rayfield/configuration/themes
            ToggleUIKeybind      = "P", -- The keybind to toggle the UI visibility (string like "K" or Enum.KeyCode)
             DisableRayfieldPrompts = false,
              DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface
               ConfigurationSaving  = {
                Enabled           = true,
                 FolderName        = "CatSSIsprettygoodtbh1", -- Create a custom folder for your hub/game
                  FileName          = "CatSSIsprettygoodHub1"                                      },
                   Discord           = {
                    Enabled           = false, -- Prompt the user to join your Discord server if their executor supports it
                     Invite            = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
                       RememberJoins     = true --[[ Set this to false to make them join the discord every time they load it up ]] },
                        KeySystem = false, -- Set this to true to use our key system
                         KeySettings = {
                          Title    = " This is  " ..localPlayer.DisplayName .. "'s Key system . . .",
                           Subtitle = "Key System",
                            Note     = " "..localPlayer.DisplayName .." Your key is 1234 please type it in below!", -- Use this to tell the user how to get a key
                             FileName = "Key_$k1tt3nistheownerof$h0ckC4t$tudi0s", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
                              SaveKey  = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
                               GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
                                Key      =   {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})
----------------------------------------------------------------------------
--MainWindow Maker(s)
---------------------------------------------------------------------------- 
local Tab01   =    MainWindow:CreateTab  ("NameIsWIP1"             ,          "app-window-mac") -- Title, Image
local Tab02   =    MainWindow:CreateTab  ("NameIsWIP2"             ,                 "annoyed") -- Title, Image
local Tab03   =    MainWindow:CreateTab  ("NameIsWIP3"             ,          'chevrons-right')
local Tab04   =    MainWindow:CreateTab  ("NameIsWIP4"             ,                "scan-eye")
local Tab05   =    MainWindow:CreateTab  ("NameIsWIP5"             ,                'workflow')
local Tab06   =    MainWindow:CreateTab  ("NameIsWIP6"             ,          'laptop-minimal')
local Tab07   =    MainWindow:CreateTab  ("NameIsWIP7"             ,            'shield-alert')
local Tab08   =    MainWindow:CreateTab  ("NameIsWIP8"             ,  'gallery-horizontal-end')
local Tab09   =    MainWindow:CreateTab  ("NameIsWIP9"             ,              'settings-2')
local Tab10   =    MainWindow:CreateTab  ("NameIsWIP10"             ,                     'cog')
local Tab11   =    MainWindow:CreateTab  ("NameIsWIPso-on"             ,                     'cog')
local Tab12   =    MainWindow:CreateTab  ("NameIsWIP11"             ,                     "cog")
local Tab13   =    MainWindow:CreateTab  ("NameIsWIP12"             ,                    "bolt")
local Tab14   =    MainWindow:CreateTab  ("NameIsWIP13"             ,                     "cog")
local Tab15   =    MainWindow:CreateTab  ("NameIsWIP14"             ,                     "cog")
local Tab16   =    MainWindow:CreateTab  ("NameIsWIP15"             ,                     "cog") -- Title, Image
local Tab17   =    MainWindow:CreateTab  ("NameIsWIP16"             ,                     "cog") -- Title, Image
local Tab18   =    MainWindow:CreateTab  ("NameIsWIP17"             ,                     "cog") -- Title, Image
local Tab19   =    MainWindow:CreateTab  ("NameIsWIP18"             ,                     "cog")
local Tab21   =    MainWindow:CreateTab  ("NameIsWIP19"             ,                     "cog") -- Title, Image
local Tab22   =    MainWindow:CreateTab  ("nan"             ,                     "cog")
local Tab23   =    MainWindow:CreateTab  ("ErrorTabs"             ,                     "cog") -- Title, Image
      Tab     =    Tab23
----------------------------------------------------------------------------
--Tabs /\ 15
---------------------------------------------------------------------------
--Tab for \|/ (    Shedletsky morph     )
local Section1 = Tab23:CreateSection("Shedletsky")

local Button1 = Tab:CreateButton({
   Name = "Shedletsky morph",
   Callback = function()
   -- The function that takes place when the button is pressed
   loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/Shedletsky%20morph%20art'))()
   end,
})
--        /|\                /|\
---------------------------------------------------------------------------
--Tab for \|/ (    GenSpawnButton     )
local Section2 = Tab23:CreateSection("GenSpawnGui")

local Button2 = Tab23:CreateButton({
   Name = "GenSpawnGui",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('  https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/GenSpawnButton  '))() 
      -- The function that takes place when the button is pressed
   end,
})
--        /|\                /|\
---------------------------------------------------------------------------
--Tab for \|/ (         )
local Section3 = Tab23:CreateSection("Bad Esp")

local Button3 = Tab:CreateButton({
   Name = "Bad Esp",
   Callback = function()
   -- The function that takes place when the button is pressed
   loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/Esp%20BAD'))()
      -- The function that takes place when the button is pressed
   end,
})
--        /|\             /|\
---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section4 = Tab23:CreateSection("WIP")

local Button4 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})
--        /|\             /|\
---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section5 = Tab23:CreateSection("WIP")

local Button5 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})
--        /|\             /|\
---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section6 = Tab23:CreateSection("WIP")

local Button6 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})
--        /|\             /|\
---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section7 = Tab23:CreateSection("WIP")

local Button7 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})
--        /|\             /|\
---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section8 = Tab23:CreateSection("WIP")

local Button8 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})
--        /|\             /|\
---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section9 = Tab23:CreateSection("WIP")

local Button9 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})

--        /|\                       /|\
----------------------------------------------------------------------------
--Tab for \|/ (     Fake block    ) \|/
local Section9 = Tab23:CreateSection("Fblock")

local Button9 = Tab:CreateButton({
   Name = "Fblock",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('  https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/Fblock  '))()
      -- The function that takes place when the button is pressed
   end,
})

--        /|\                /|\
----------------------------------------------------------------------------
--// Tab for \|/ (    speed and StaminaGain     )    \|/
local Section9 = Tab23:CreateSection("Speed/Stam")

--// Button to load external script from GitHub
local Button9 = Tab23:CreateButton({
   Name = "S&Stam",
   Callback = function()
      -- Replace the link below with your GitHub raw URL
      local Rayfield = loadstring(game:HttpGet("https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/speed%20stam"))()
   end,
})

--// Toggle for Speed
local SpeedToggle = Tab23:CreateToggle({
   Name = "Speed (Both)",
   CurrentValue = false,
   Callback = function(state)
      -- state = true when toggled ON, false when OFF
      local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
      if state then
         -- Enable modified speed
         sprintingModule.SprintSpeed = 26.5
         sprintingModule.StaminaGain = 21.5
         print("‚ö° Speed Boost Activated!")
      else
         -- Reset to default
         sprintingModule.SprintSpeed = 26
         sprintingModule.StaminaGain = 21
         print("üèÉ Speed Reset to Default.")
      end
   end,
})

--// Toggle for Stamina Gain
local StaminaToggle = Tab23:CreateToggle({
   Name = "Stamina Gain (s)",
   CurrentValue = false,
   Callback = function(state)
      local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
      if state then
         -- Modify stamina regen
         sprintingModule.StaminaGain = 22
         print("üí® Stamina Gain Increased!")
      else
         -- Reset
         sprintingModule.StaminaGain = 21
         print("üí§ Stamina Gain Reset.")
      end
   end,
})

--        /|\                /|\
----------------------------------------------------------------------------

---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section9 = Tab23:CreateSection("WIP")

local Button9 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})

--        /|\                /|\
----------------------------------------------------------------------------

---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section9 = Tab23:CreateSection("WIP")

local Button9 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})

--        /|\                /|\
----------------------------------------------------------------------------

---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section9 = Tab23:CreateSection("WIP")

local Button9 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})

--        /|\                /|\
----------------------------------------------------------------------------

---------------------------------------------------------------------------
--Tab for \|/ (         ) \|/
local Section9 = Tab23:CreateSection("WIP")

local Button9 = Tab:CreateButton({
   Name = "ButtonWip",
   Callback = function()
   -- The function that takes place when the button is pressed
   local Rayfield = loadstring(game:HttpGet('    '))()
      -- The function that takes place when the button is pressed
   end,
})

--        /|\                /|\
----------------------------------------------------------------------------










----------------------------------------------------------------------------
--   (normal) \/   Auto farm                                                        
----------------------------------------------------------------------------
local Button = Tab12:CreateButton({
   Name = "Button Example",
   Callback = function()
   -- The function that takes place when the button is pressed
        loadstring(game:HttpGet("https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/0c729e63175b330c47a26c66847aa69b161b0908/auto%20farm%20untested"))()  -- Executes the code from GitHub end)
  -- The function that takes place when the button is pressed
   end,
})
----------------------------------------------------------------------------
--  (normal) /\                                                            
----------------------------------------------------------------------------




---------------------------------------------------------------------------
--Fixer upper in german start
---------------------------------------------------------------------------
local Section = Tab8:CreateSection("player")

local Button = Tab:CreateButton({
   Name = "invisible (beta)",
   Callback = function()
   local Players = game:GetService("Players")

local function setInvisible(player)
    local character = player.Character
    if not character then return end

    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            part.Transparency = 1  -- –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π
            part.CanCollide = false -- –ù–µ—Ç —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
        elseif part:IsA("Decal") or part:IsA("Texture") then
            part.Transparency = 1
        end
    end
end
local function setVisible(player)
    local character = player.Character
    if not character then return end
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            part.Transparency = 0
            part.CanCollide = true
        elseif part:IsA("Decal") or part:IsA("Texture") then
            part.Transparency = 0
        end
    end
end

-- –ü—Ä–∏–º–µ—Ä –≤—ã–∑–æ–≤–∞:
local player = Players.LocalPlayer  -- –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–∫—Ä–∏–ø—Ç–∞
setInvisible(player)
-- –ß—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç—å, –≤—ã–∑–æ–≤–∏:
-- setVisible(player)
   end,
})

local Button = Tab:CreateButton({
   Name = "god mode (beta)",
   Callback = function()
   local Players = game:GetService("Players")

local function enableGodMode(player)
    local character = player.Character
    if not character then return end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        -- –û—Ç–∫–ª—é—á–∞–µ–º —É—Ä–æ–Ω —á–µ—Ä–µ–∑ —Å–æ–±—ã—Ç–∏–µ HealthChanged
        humanoid.HealthChanged:Connect(function(health)
            if health < humanoid.MaxHealth then
                humanoid.Health = humanoid.MaxHealth
            end
        end)
    end
end

-- –ü—Ä–∏–º–µ—Ä –≤—ã–∑–æ–≤–∞:
local player = Players.LocalPlayer  -- –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Å–∫—Ä–∏–ø—Ç–∞
enableGodMode(player)
   end,
})

local Tab = MainWindow:CreateTab("Esp", "rewind")
local Section = Tab:CreateSection("Esp killers, Esp players")

local Button = Tab:CreateButton({
   Name = "Esp killer",
   Callback = function()
   -- –°–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π
local killers = {
    "c00lkidd",
    "JohnDoe",
    "Jason",
    "1x1x1x1",
    "Noli"
}

-- –§—É–Ω–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è ESP
local function addESP(part)
    if part:FindFirstChild("Highlight") then return end -- —É–∂–µ –µ—Å—Ç—å ESP

    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 0, 0) -- —Ü–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255) -- —Ü–≤–µ—Ç –∫–æ–Ω—Ç—É—Ä–∞
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0.2
    highlight.Adornee = part
    highlight.Parent = part
end

-- –ê–≤—Ç–æ-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ 0.5 —Å–µ–∫
while task.wait(0.5) do
    for _, killerName in ipairs(killers) do
        local path = game:GetService("Workspace"):FindFirstChild("Players")
        if path and path:FindFirstChild("Killers") then
            local killer = path.Killers:FindFirstChild(killerName)
            if killer and killer:FindFirstChild("QueryHitbox") then
                addESP(killer.QueryHitbox)
            end
        end
    end
end
   end,
})

local Button = Tab:CreateButton({
   Name = "Esp Players",
   Callback = function()
   -- –¶–≤–µ—Ç ESP
local ESP_COLOR = Color3.fromRGB(0, 170, 255) -- –≥–æ–ª—É–±–æ–π

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏
local function addHighlight(part)
    if not part:FindFirstChild("Highlight") then
        local hl = Instance.new("Highlight")
        hl.FillColor = ESP_COLOR
        hl.OutlineColor = Color3.fromRGB(255, 110, 255)
        hl.FillTransparency = 0.5
        hl.OutlineTransparency = 0
        hl.Adornee = part
        hl.Parent = part
    end
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–º–µ–Ω–∏ –∏ –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
local function addBillboard(part, name)
    if not part:FindFirstChild("ESPName") then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESPName"
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.AlwaysOnTop = true
        billboard.StudsOffset = Vector3.new(0, 2, 0)
        billboard.Parent = part

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.fromRGB(0, 255, 255)
        textLabel.TextStrokeTransparency = 0
        textLabel.Font = Enum.Font.GothamBold
        textLabel.TextSize = 14
        textLabel.Parent = billboard

        -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
        task.spawn(function()
            while billboard.Parent do
                local distance = math.floor((workspace.CurrentCamera.CFrame.Position - part.Position).Magnitude)
                textLabel.Text = name .. " [" .. distance .. "m]"
                task.wait(0.2)
            end
        end)
    end
end

-- –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª ESP
task.spawn(function()
    while task.wait(0.5) do
        for _, plr in ipairs(game.Players:GetPlayers()) do
            if plr ~= game.Players.LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                addHighlight(plr.Character.HumanoidRootPart)
                addBillboard(plr.Character.HumanoidRootPart, plr.Name)
            end
        end
    end
end)
   end,
})

local Button = Tab:CreateButton({
   Name = "Esp generators",
   Callback = function()
   local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")

local mapFolder = workspace.Map.Ingame.Map

-- –°–æ–∑–¥–∞–µ–º ESP –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞ –≤ –ø–∞–ø–∫–µ
for _, obj in pairs(mapFolder:GetChildren()) do
    if obj:IsA("BasePart") then
        local billboard = Instance.new("BillboardGui")
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.AlwaysOnTop = true
        billboard.Adornee = obj
        billboard.Parent = obj

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.new(1, 0, 0)
        textLabel.TextScaled = true
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.Parent = billboard

        runService.RenderStepped:Connect(function()
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local distance = (player.Character.HumanoidRootPart.Position - obj.Position).Magnitude
                textLabel.Text = string.format("Generator / %d m", math.floor(distance))
            end
        end)
    end
end
   end,
})

local Tab = MainWindow:CreateTab("Afk", "rewind")
local Section = Tab:CreateSection("Afk teleport, afk platform")

local Button = Tab:CreateButton({
   Name = "Afk Teleport",
   Callback = function()
   -- –°–ø–∏—Å–æ–∫ –∏–º—ë–Ω –∫–∏–ª–ª–µ—Ä–æ–≤
local killers = {
    "c00lkidd",
    "JohnDoe",
    "Jason",
    "1x1x1x1",
    "Noli"
}

-- –ü–æ—Ä–æ–≥ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è –≤ —Å—Ç—É–¥—Å–∞—Ö
local TRIGGER_DISTANCE = 15

-- –ö—É–¥–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å (–ø—Ä–∏–º–µ—Ä–Ω–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è)
local SAFE_POSITION = Vector3.new(1000, 100, 1000) -- –ø–æ–º–µ–Ω—è–π –Ω–∞ —Å–≤–æ—é

-- –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏
local function checkKillers()
    local lp = game.Players.LocalPlayer
    if not (lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")) then return end
    local myPos = lp.Character.HumanoidRootPart.Position

    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, name in ipairs(killers) do
            local killer = killersFolder:FindFirstChild(name)
            if killer and killer:FindFirstChild("QueryHitbox") then
                local distance = (killer.QueryHitbox.Position - myPos).Magnitude
                if distance <= TRIGGER_DISTANCE then
                    -- –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏–≥—Ä–æ–∫–∞
                    lp.Character.HumanoidRootPart.CFrame = CFrame.new(SAFE_POSITION)
                    print("–¢–µ–ª–µ–ø–æ—Ä—Ç –∏–∑-–∑–∞ –±–ª–∏–∑–æ—Å—Ç–∏ –∫–∏–ª–ª–µ—Ä–∞:", name)
                    break
                end
            end
        end
    end
end

-- –ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏
task.spawn(function()
    while task.wait(0.1) do
        checkKillers()
    end
end)
   end,
})

local Tab = MainWindow:CreateTab("hitbox", "rewind")
local Section = Tab:CreateSection("hitbox players, hitbox killer")

local Button = Tab:CreateButton({
   Name = "hitbox players",
   Callback = function()
   -- –ú–Ω–æ–∂–∏—Ç–µ–ª—å —Ä–∞–∑–º–µ—Ä–∞
local SIZE_MULTIPLIER = 5

-- –§—É–Ω–∫—Ü–∏—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è —Ö–∏—Ç–±–æ–∫—Å–æ–≤
local function enlargeHitbox(character)
    if character and character:FindFirstChild("HumanoidRootPart") then
        local hrp = character.HumanoidRootPart
        hrp.Size = Vector3.new(2, 2, 1) * SIZE_MULTIPLIER
        hrp.Transparency = 0.7 -- —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å —Ä–∞–∑–º–µ—Ä (–º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å)
        hrp.BrickColor = BrickColor.new("Really red") -- —Ü–≤–µ—Ç –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏
        hrp.Material = Enum.Material.Neon
        hrp.CanCollide = false
    end
end

-- –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
task.spawn(function()
    while task.wait(0.5) do
        for _, plr in ipairs(game.Players:GetPlayers()) do
            if plr ~= game.Players.LocalPlayer and plr.Character then
                enlargeHitbox(plr.Character)
            end
        end
    end
end)
   end,
})

local Button = Tab:CreateButton({
   Name = "hitbox killer",
   Callback = function()
   -- –°–ø–∏—Å–æ–∫ –∏–º—ë–Ω –∫–∏–ª–ª–µ—Ä–æ–≤
local killers = {
    "c00lkidd",
    "JohnDoe",
    "Jason",
    "1x1x1x1",
    "Noli"
}

-- –ú–Ω–æ–∂–∏—Ç–µ–ª—å —Ä–∞–∑–º–µ—Ä–∞
local SIZE_MULTIPLIER = 5

-- –§—É–Ω–∫—Ü–∏—è —É–≤–µ–ª–∏—á–µ–Ω–∏—è —Ö–∏—Ç–±–æ–∫—Å–æ–≤
local function enlargeHitbox(model)
    if model and model:FindFirstChild("HumanoidRootPart") then
        local hrp = model.HumanoidRootPart
        hrp.Size = Vector3.new(2, 2, 1) * SIZE_MULTIPLIER
        hrp.Transparency = 0.7 -- –¥–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏, –º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å
        hrp.BrickColor = BrickColor.new("Really red")
        hrp.Material = Enum.Material.Neon
        hrp.CanCollide = false
    end
end

-- –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
task.spawn(function()
    while task.wait(0.5) do
        local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
        if killersFolder then
            for _, name in ipairs(killers) do
                local killer = killersFolder:FindFirstChild(name)
                if killer then
                    enlargeHitbox(killer)
                end
            end
        end
    end
end)
   end,
})

local Tab = MainWindow:CreateTab("teleport", "rewind")
local Section = Tab:CreateSection("teleport")

local Button = Tab:CreateButton({
   Name = "teleport to player",
   Callback = function()
   local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- –°–æ–∑–¥–∞–Ω–∏–µ GUI
local screenGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
screenGui.Name = "TPMenu"

local frame = Instance.new("Frame", screenGui)
frame.Size = UDim2.new(0, 300, 0, 200)
frame.Position = UDim2.new(0.5, -150, 0.5, -100)
frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
frame.BorderSizePixel = 0

-- –í—ã–±—Ä–∞–Ω–Ω—ã–π –∏–≥—Ä–æ–∫
local selectedPlayer = nil

-- –°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤
local uiList = Instance.new("UIListLayout", frame)
uiList.SortOrder = Enum.SortOrder.LayoutOrder

-- –ó–∞–≥–æ–ª–æ–≤–æ–∫
local title = Instance.new("TextLabel", frame)
title.Size = UDim2.new(1, 0, 0, 30)
title.Text = "–í—ã–±–µ—Ä–∏ –∏–≥—Ä–æ–∫–∞:"
title.TextColor3 = Color3.new(1, 1, 1)
title.BackgroundTransparency = 1
title.Font = Enum.Font.SourceSansBold
title.TextSize = 20

-- –ö–Ω–æ–ø–∫–∏ –∏–≥—Ä–æ–∫–æ–≤
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        local btn = Instance.new("TextButton", frame)
        btn.Size = UDim2.new(1, 0, 0, 30)
        btn.Text = player.Name
        btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
        btn.TextColor3 = Color3.new(1, 1, 1)
        btn.Font = Enum.Font.SourceSans
        btn.TextSize = 18

        btn.MouseButton1Click:Connect(function()
            selectedPlayer = player
            -- –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞
            for _, otherBtn in pairs(frame:GetChildren()) do
                if otherBtn:IsA("TextButton") then
                    otherBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                end
            end
            btn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        end)
    end
end

-- –ö–Ω–æ–ø–∫–∞ "–¢–ü"
local tpButton = Instance.new("TextButton", frame)
tpButton.Size = UDim2.new(1, 0, 0, 30)
tpButton.Text = "–¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å—Å—è"
tpButton.BackgroundColor3 = Color3.fromRGB(70, 120, 70)
tpButton.TextColor3 = Color3.new(1, 1, 1)
tpButton.Font = Enum.Font.SourceSansBold
tpButton.TextSize = 18

tpButton.MouseButton1Click:Connect(function()
    if selectedPlayer and selectedPlayer.Character and selectedPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = selectedPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(2, 0, 0)
        end
    end
    screenGui:Destroy() -- –£–¥–∞–ª–∏—Ç—å –º–µ–Ω—é –ø–æ—Å–ª–µ –¢–ü
end)
   end,
})

local Tab = MainWindow:CreateTab("Credits", "rewind")
local Section = Tab:CreateSection("Credits")

local Button = Tab:CreateButton({
   Name = "gogslo2111 = Robanik = —Å–æ–∑–¥–∞—Ç–µ–ª—å",
   Callback = function()
   -- The function that takes place when the button is pressed
   end,
})

local Button = Tab:CreateButton({
   Name = "random_beast5 = Sombrita_games = —Ç–µ—Å—Ç–µ—Ä",
   Callback = function()
   -- The function that takes place when the button is pressed
   end,
})

---------------------------------------------------------------------------
--Fixer upper in german end
---------------------------------------------------------------------------
---------------------------------------------------------------------------
--alot of stuff exploits mostly esp and stam as ive seen
---------------------------------------------------------------------------

local Toggle = PlayerTab:CreateToggle({
   Name = "Infinite Stamina",
   CurrentValue = false,
   Flag = "Toggle341",
   Callback = function(Value)
       if Value then
           local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
           
           local originalStaminaChange = sprintingModule.ChangeStat
           sprintingModule.ChangeStat = function(self, stat, value)
               if stat == "Stamina" then
                   return
               end
               return originalStaminaChange(self, stat, value)
           end
           
           local originalInit = sprintingModule.Init
           sprintingModule.Init = function(self)
               originalInit(self)
               
               self.StaminaLossDisabled = true
               self.Stamina = self.MaxStamina
               
               local staminaLoop
               staminaLoop = game:GetService("RunService").Heartbeat:Connect(function()
                   if self.Stamina < self.MaxStamina then
                       self.Stamina = self.MaxStamina
                       if self.__staminaChangedEvent then
                           self.__staminaChangedEvent:Fire(self.MaxStamina)
                       end
                   end
               end)
               
               self._infiniteStaminaLoop = staminaLoop
           end
           
           if sprintingModule.DefaultsSet then
               sprintingModule.StaminaLossDisabled = true
               sprintingModule.Stamina = sprintingModule.MaxStamina
               
               if not sprintingModule._infiniteStaminaLoop then
                   local staminaLoop = game:GetService("RunService").Heartbeat:Connect(function()
                       if sprintingModule.Stamina < sprintingModule.MaxStamina then
                           sprintingModule.Stamina = sprintingModule.MaxStamina
                           if sprintingModule.__staminaChangedEvent then
                               sprintingModule.__staminaChangedEvent:Fire(sprintingModule.MaxStamina)
                           end
                       end
                   end)
                   sprintingModule._infiniteStaminaLoop = staminaLoop
               end
           end
           
           _G.InfiniteStaminaData = {
               OriginalChangeStat = originalStaminaChange,
               OriginalInit = originalInit,
               Module = sprintingModule
           }
           
       else
           if _G.InfiniteStaminaData then
               local sprintingModule = _G.InfiniteStaminaData.Module
               
               sprintingModule.ChangeStat = _G.InfiniteStaminaData.OriginalChangeStat
               sprintingModule.Init = _G.InfiniteStaminaData.OriginalInit
               sprintingModule.StaminaLossDisabled = false
               
               if sprintingModule._infiniteStaminaLoop then
                   sprintingModule._infiniteStaminaLoop:Disconnect()
                   sprintingModule._infiniteStaminaLoop = nil
               end
               
               _G.InfiniteStaminaData = nil
           end
       end
   end,
})
local Input = PlayerTab:CreateInput({
   Name = "Speed",
   CurrentValue = "",
   PlaceholderText = "Enter sprint speed",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
       local newSpeed = tonumber(Text)
       if newSpeed then
           local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
           
           if sprintingModule then
               sprintingModule.SprintSpeed = newSpeed
               
               if sprintingModule.IsSprinting and sprintingModule.__speedMultiplier then
                   local humanoid = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
                   if humanoid then
                       local baseSpeed = humanoid:GetAttribute("BaseSpeed") or 16
                       sprintingModule.__speedMultiplier.Value = newSpeed / baseSpeed
                   end
               end
           end
       end
   end,
})
local Input = PlayerTab:CreateInput({
   Name = "Stamina gain/sec",
   CurrentValue = "",
   PlaceholderText = "Enter stamina gain per second",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Text)
       local newGain = tonumber(Text)
       if newGain then
           local sprintingModule = require(game:GetService("ReplicatedStorage").Systems.Character.Game.Sprinting)
           
           if sprintingModule then
               sprintingModule.StaminaGain = newGain
           end
       end
   end,
})
local Toggle = Tab:CreateToggle({
   Name = "Killer esp",
   CurrentValue = false,
   Flag = "Togg22le1",
   Callback = function(Value)
       if Value then
           if not _G.KillerESPData then
               _G.KillerESPData = {
                   Highlights = {},
                   Connections = {}
               }
           end

           local function isKiller(model)
               return model:IsA("Model") and model.Parent and model.Parent.Name == "Killers" and model.Parent.Parent and model.Parent.Parent.Name == "Players" and model.Parent.Parent.Parent == game.Workspace
           end

           local function updateKillerESP()
               for killer, highlight in pairs(_G.KillerESPData.Highlights) do
                   if killer and killer.Parent then
                       highlight.Adornee = killer
                       highlight.Enabled = true
                   else
                       highlight.Enabled = false
                   end
               end
           end

           local function createKillerESP(killer)
               if not isKiller(killer) then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = killer.Name .. "_KillerESP"
               highlight.FillColor = Color3.fromRGB(255, 0, 0)
               highlight.FillTransparency = 0.5
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               _G.KillerESPData.Highlights[killer] = highlight
           end

           local function scanForKillers()
               local playersFolder = game.Workspace:FindFirstChild("Players")
               if playersFolder then
                   local killersFolder = playersFolder:FindFirstChild("Killers")
                   if killersFolder then
                       for _, killer in pairs(killersFolder:GetChildren()) do
                           if killer:IsA("Model") then
                               createKillerESP(killer)
                           end
                       end
                   end
               end
           end

           scanForKillers()

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Killers" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Players" and grandParent.Parent == game.Workspace then
                           createKillerESP(descendant)
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.KillerESPData.Highlights[descendant] then
                   _G.KillerESPData.Highlights[descendant]:Destroy()
                   _G.KillerESPData.Highlights[descendant] = nil
               end
           end

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(handleDescendantAdded)
           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.KillerESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.KillerESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateKillerESP()
           end)

       else
           if _G.KillerESPData then
               if _G.KillerESPData.UpdateLoop then
                   _G.KillerESPData.UpdateLoop:Disconnect()
               end

               if _G.KillerESPData.MainConnections then
                   _G.KillerESPData.MainConnections.descendantAdded:Disconnect()
                   _G.KillerESPData.MainConnections.descendantRemoving:Disconnect()
               end

               for killer, highlight in pairs(_G.KillerESPData.Highlights) do
                   highlight:Destroy()
               end

               _G.KillerESPData = nil
           end
       end
   end,
})
local Toggle = Tab:CreateToggle({
   Name = "Players' esp",
   CurrentValue = false,
   Flag = "Togg213le1",
   Callback = function(Value)
       if Value then
           if not _G.SurvivorESPData then
               _G.SurvivorESPData = {
                   Highlights = {},
                   Connections = {}
               }
           end

           local function isSurvivor(model)
               return model:IsA("Model") and model.Parent and model.Parent.Name == "Survivors" and model.Parent.Parent and model.Parent.Parent.Name == "Players" and model.Parent.Parent.Parent == game.Workspace and model ~= game.Players.LocalPlayer.Character
           end

           local function updateSurvivorESP()
               for survivor, highlight in pairs(_G.SurvivorESPData.Highlights) do
                   if survivor and survivor.Parent then
                       highlight.Adornee = survivor
                       highlight.Enabled = true
                   else
                       highlight.Enabled = false
                   end
               end
           end

           local function createSurvivorESP(survivor)
               if not isSurvivor(survivor) then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = survivor.Name .. "_SurvivorESP"
               highlight.FillColor = Color3.fromRGB(0, 255, 0)
               highlight.FillTransparency = 0.6
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               _G.SurvivorESPData.Highlights[survivor] = highlight
           end

           local function scanForSurvivors()
               local playersFolder = game.Workspace:FindFirstChild("Players")
               if playersFolder then
                   local survivorsFolder = playersFolder:FindFirstChild("Survivors")
                   if survivorsFolder then
                       for _, survivor in pairs(survivorsFolder:GetChildren()) do
                           if survivor:IsA("Model") then
                               createSurvivorESP(survivor)
                           end
                       end
                   end
               end
           end

           scanForSurvivors()

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Survivors" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Players" and grandParent.Parent == game.Workspace then
                           createSurvivorESP(descendant)
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.SurvivorESPData.Highlights[descendant] then
                   _G.SurvivorESPData.Highlights[descendant]:Destroy()
                   _G.SurvivorESPData.Highlights[descendant] = nil
               end
           end

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(handleDescendantAdded)
           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.SurvivorESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.SurvivorESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateSurvivorESP()
           end)

       else
           if _G.SurvivorESPData then
               if _G.SurvivorESPData.UpdateLoop then
                   _G.SurvivorESPData.UpdateLoop:Disconnect()
               end

               if _G.SurvivorESPData.MainConnections then
                   _G.SurvivorESPData.MainConnections.descendantAdded:Disconnect()
                   _G.SurvivorESPData.MainConnections.descendantRemoving:Disconnect()
               end

               for survivor, highlight in pairs(_G.SurvivorESPData.Highlights) do
                   highlight:Destroy()
               end

               _G.SurvivorESPData = nil
           end
       end
   end,
})
local Toggle = Tab:CreateToggle({
   Name = "Item esp",
   CurrentValue = false,
   Flag = "Togg1111le1",
   Callback = function(Value)
       if Value then
           if not _G.ItemESPData then
               _G.ItemESPData = {
                   Highlights = {},
                   Billboards = {},
                   Connections = {}
               }
           end

           local function isTargetItem(model)
               return model:IsA("Model") and (model.Name == "BloxyCola" or model.Name == "Medkit") and 
                      model.Parent and model.Parent.Name == "Map" and 
                      model.Parent.Parent and model.Parent.Parent.Name == "Ingame" and 
                      model.Parent.Parent.Parent and model.Parent.Parent.Parent.Name == "Map" and 
                      model.Parent.Parent.Parent.Parent == game.Workspace
           end

           local function updateItemESP()
               for item, data in pairs(_G.ItemESPData.Highlights) do
                   if item and item.Parent then
                       data.highlight.Adornee = item
                       data.highlight.Enabled = true
                       if data.billboard then
                           data.billboard.Adornee = item
                           data.billboard.Enabled = true
                       end
                   else
                       data.highlight.Enabled = false
                       if data.billboard then
                           data.billboard.Enabled = false
                       end
                   end
               end
           end

           local function createItemESP(item)
               if not isTargetItem(item) then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = item.Name .. "_ItemESP"
               highlight.FillColor = Color3.fromRGB(128, 0, 128)
               highlight.FillTransparency = 0.5
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.1
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               local billboard = Instance.new("BillboardGui")
               billboard.Name = item.Name .. "_Label"
               billboard.Size = UDim2.new(0, 80, 0, 20)
               billboard.StudsOffset = Vector3.new(0, 2, 0)
               billboard.AlwaysOnTop = true
               billboard.Adornee = item
               billboard.Parent = game.CoreGui
               
               local textLabel = Instance.new("TextLabel")
               textLabel.Size = UDim2.new(1, 0, 1, 0)
               textLabel.BackgroundTransparency = 1
               textLabel.Text = item.Name
               textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
               textLabel.TextSize = 12
               textLabel.Font = Enum.Font.SourceSansBold
               textLabel.TextStrokeTransparency = 0
               textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
               textLabel.Parent = billboard
               
               _G.ItemESPData.Highlights[item] = {
                   highlight = highlight,
                   billboard = billboard
               }
           end

           local function scanForItems()
               local mapFolder = game.Workspace:FindFirstChild("Map")
               if mapFolder then
                   local ingameFolder = mapFolder:FindFirstChild("Ingame")
                   if ingameFolder then
                       local mapSubFolder = ingameFolder:FindFirstChild("Map")
                       if mapSubFolder then
                           for _, item in pairs(mapSubFolder:GetDescendants()) do
                               if item:IsA("Model") and (item.Name == "BloxyCola" or item.Name == "Medkit") then
                                   createItemESP(item)
                               end
                           end
                       end
                   end
               end
           end

           scanForItems()

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") and (descendant.Name == "BloxyCola" or descendant.Name == "Medkit") then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Map" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Ingame" then
                           local greatGrandParent = grandParent.Parent
                           if greatGrandParent and greatGrandParent.Name == "Map" and greatGrandParent.Parent == game.Workspace then
                               createItemESP(descendant)
                           end
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.ItemESPData.Highlights[descendant] then
                   local data = _G.ItemESPData.Highlights[descendant]
                   data.highlight:Destroy()
                   if data.billboard then
                       data.billboard:Destroy()
                   end
                   _G.ItemESPData.Highlights[descendant] = nil
               end
           end

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(handleDescendantAdded)
           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.ItemESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.ItemESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateItemESP()
           end)

       else
           if _G.ItemESPData then
               if _G.ItemESPData.UpdateLoop then
                   _G.ItemESPData.UpdateLoop:Disconnect()
               end

               if _G.ItemESPData.MainConnections then
                   _G.ItemESPData.MainConnections.descendantAdded:Disconnect()
                   _G.ItemESPData.MainConnections.descendantRemoving:Disconnect()
               end

               for item, data in pairs(_G.ItemESPData.Highlights) do
                   data.highlight:Destroy()
                   if data.billboard then
                       data.billboard:Destroy()
                   end
               end

               _G.ItemESPData = nil
           end
       end
   end,
})
local Toggle = Tab:CreateToggle({
   Name = "Generators' esp",
   CurrentValue = false,
   Flag = "Toggl323e1",
   Callback = function(Value)
       if Value then
           if not _G.GeneratorESPData then
               _G.GeneratorESPData = {
                   Highlights = {},
                   Billboards = {},
                   Connections = {}
               }
           end

           local function isGenerator(model)
               return model:IsA("Model") and model.Name == "Generator" and 
                      model.Parent and model.Parent.Name == "Map" and 
                      model.Parent.Parent and model.Parent.Parent.Name == "Ingame" and 
                      model.Parent.Parent.Parent and model.Parent.Parent.Parent.Name == "Map" and 
                      model.Parent.Parent.Parent.Parent == game.Workspace
           end

           -- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
           local function getGeneratorProgress(generator)
               local progressValue = generator:FindFirstChild("Progress")
               if progressValue and progressValue:IsA("NumberValue") then
                   return progressValue.Value
               end
               return 0
           end

           local function updateGeneratorESP()
               for generator, highlight in pairs(_G.GeneratorESPData.Highlights) do
                   if generator and generator.Parent then
                       local progress = getGeneratorProgress(generator)
                       
                       -- –ï—Å–ª–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å 100% - —Å–∫—Ä—ã–≤–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É
                       if progress >= 100 then
                           highlight.Enabled = false
                           if _G.GeneratorESPData.Billboards[generator] then
                               _G.GeneratorESPData.Billboards[generator].Enabled = false
                           end
                       else
                           highlight.Enabled = true
                           
                           -- –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                           if progress == 0 then
                               highlight.FillColor = Color3.fromRGB(255, 0, 0) -- –ö—Ä–∞—Å–Ω—ã–π
                           elseif progress < 50 then
                               highlight.FillColor = Color3.fromRGB(255, 165, 0) -- –û—Ä–∞–Ω–∂–µ–≤—ã–π
                           elseif progress < 100 then
                               highlight.FillColor = Color3.fromRGB(255, 255, 0) -- –ñ–µ–ª—Ç—ã–π
                           end
                           
                           -- –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                           if _G.GeneratorESPData.Billboards[generator] then
                               _G.GeneratorESPData.Billboards[generator].TextLabel.Text = math.floor(progress) .. "%"
                               _G.GeneratorESPData.Billboards[generator].Enabled = true
                           end
                       end
                       
                       highlight.Adornee = generator
                   else
                       highlight.Enabled = false
                       if _G.GeneratorESPData.Billboards[generator] then
                           _G.GeneratorESPData.Billboards[generator].Enabled = false
                       end
                   end
               end
           end

           local function createGeneratorESP(generator)
               if not isGenerator(generator) then return end
               
               -- –°–æ–∑–¥–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É
               local highlight = Instance.new("Highlight")
               highlight.Name = generator.Name .. "_GeneratorESP"
               highlight.FillColor = Color3.fromRGB(255, 0, 0) -- –ù–∞—á–∞–ª—å–Ω—ã–π —Ü–≤–µ—Ç –∫—Ä–∞—Å–Ω—ã–π
               highlight.FillTransparency = 0.6
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               -- –°–æ–∑–¥–∞–µ–º BillboardGui –¥–ª—è —Ç–µ–∫—Å—Ç–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
               local billboard = Instance.new("BillboardGui")
               billboard.Name = generator.Name .. "_ProgressText"
               billboard.Adornee = generator:FindFirstChild("PrimaryPart") or generator:FindFirstChildWhichIsA("BasePart")
               billboard.Size = UDim2.new(0, 100, 0, 40)
               billboard.StudsOffset = Vector3.new(0, 3, 0)
               billboard.AlwaysOnTop = true
               billboard.MaxDistance = 100
               
               local textLabel = Instance.new("TextLabel")
               textLabel.Size = UDim2.new(1, 0, 1, 0)
               textLabel.BackgroundTransparency = 1
               textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
               textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
               textLabel.TextStrokeTransparency = 0
               textLabel.TextSize = 14
               textLabel.Font = Enum.Font.GothamBold
               textLabel.Text = "0%"
               textLabel.Parent = billboard
               
               billboard.Parent = game.CoreGui
               
               _G.GeneratorESPData.Highlights[generator] = highlight
               _G.GeneratorESPData.Billboards[generator] = billboard
           end

           local function scanForGenerators()
               local mapFolder = game.Workspace:FindFirstChild("Map")
               if mapFolder then
                   local ingameFolder = mapFolder:FindFirstChild("Ingame")
                   if ingameFolder then
                       local mapSubFolder = ingameFolder:FindFirstChild("Map")
                       if mapSubFolder then
                           for _, generator in pairs(mapSubFolder:GetDescendants()) do
                               if generator:IsA("Model") and generator.Name == "Generator" then
                                   createGeneratorESP(generator)
                               end
                           end
                       end
                   end
               end
           end

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") and descendant.Name == "Generator" then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Map" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Ingame" then
                           local greatGrandParent = grandParent.Parent
                           if greatGrandParent and greatGrandParent.Name == "Map" and greatGrandParent.Parent == game.Workspace then
                               createGeneratorESP(descendant)
                           end
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.GeneratorESPData.Highlights[descendant] then
                   _G.GeneratorESPData.Highlights[descendant]:Destroy()
                   _G.GeneratorESPData.Highlights[descendant] = nil
               end
               if _G.GeneratorESPData.Billboards[descendant] then
                   _G.GeneratorESPData.Billboards[descendant]:Destroy()
                   _G.GeneratorESPData.Billboards[descendant] = nil
               end
           end

           -- –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
           local function monitorProgressChanges()
               for generator, _ in pairs(_G.GeneratorESPData.Highlights) do
                   local progressValue = generator:FindFirstChild("Progress")
                   if progressValue and progressValue:IsA("NumberValue") then
                       if not _G.GeneratorESPData.Connections[generator] then
                           _G.GeneratorESPData.Connections[generator] = progressValue:GetPropertyChangedSignal("Value"):Connect(function()
                               updateGeneratorESP()
                           end)
                       end
                   end
               end
           end

           scanForGenerators()
           monitorProgressChanges()

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(function(descendant)
               handleDescendantAdded(descendant)
               task.wait(0.1) -- –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
               monitorProgressChanges()
           end)

           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.GeneratorESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.GeneratorESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateGeneratorESP()
           end)

       else
           -- –û—Ç–∫–ª—é—á–∞–µ–º ESP
           if _G.GeneratorESPData then
               if _G.GeneratorESPData.UpdateLoop then
                   _G.GeneratorESPData.UpdateLoop:Disconnect()
               end

               if _G.GeneratorESPData.MainConnections then
                   _G.GeneratorESPData.MainConnections.descendantAdded:Disconnect()
                   _G.GeneratorESPData.MainConnections.descendantRemoving:Disconnect()
               end

               -- –û—Ç–∫–ª—é—á–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
               for generator, connection in pairs(_G.GeneratorESPData.Connections) do
                   connection:Disconnect()
               end

               -- –£–¥–∞–ª—è–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –∏ –±–∏–ª–±–æ—Ä–¥—ã
               for generator, highlight in pairs(_G.GeneratorESPData.Highlights) do
                   highlight:Destroy()
               end
               for generator, billboard in pairs(_G.GeneratorESPData.Billboards) do
                   billboard:Destroy()
               end

               _G.GeneratorESPData = nil
           end
       end
   end,
})
local Button = Tab:CreateButton({
   Name = "Fulbright",
   Callback = function()
       local Lighting = game:GetService("Lighting")
       
       -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
       if not _G.OriginalLightingSettings then
           _G.OriginalLightingSettings = {
               Ambient = Lighting.Ambient,
               Brightness = Lighting.Brightness,
               ColorShift_Bottom = Lighting.ColorShift_Bottom,
               ColorShift_Top = Lighting.ColorShift_Top,
               EnvironmentDiffuseScale = Lighting.EnvironmentDiffuseScale,
               EnvironmentSpecularScale = Lighting.EnvironmentSpecularScale,
               GlobalShadows = Lighting.GlobalShadows,
               OutdoorAmbient = Lighting.OutdoorAmbient,
               ShadowSoftness = Lighting.ShadowSoftness
           }
       end
       
       -- –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Fulbright –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
       Lighting.Ambient = Color3.fromRGB(255, 255, 255)
       Lighting.Brightness = 2
       Lighting.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
       Lighting.ColorShift_Top = Color3.fromRGB(0, 0, 0)
       Lighting.EnvironmentDiffuseScale = 0
       Lighting.EnvironmentSpecularScale = 0
       Lighting.GlobalShadows = false
       Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
       Lighting.ShadowSoftness = 0
       
       -- –û—Ç–∫–ª—é—á–∞–µ–º –≤—Å–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞
       for _, light in pairs(Lighting:GetChildren()) do
           if light:IsA("Light") then
               light.Enabled = false
           end
       end
   end,
})
local Toggle = Tab:CreateToggle({
   Name = "C00lkid's minions esp",
   CurrentValue = false,
   Flag = "Togglew1",
   Callback = function(Value)
       if Value then
           if not _G.MinionESPData then
               _G.MinionESPData = {
                   Highlights = {},
                   Connections = {}
               }
           end

           local function isMinion(model)
               return model:IsA("Model") and model.Name == "PizzaDeliveryRig" and 
                      model.Parent and model.Parent.Name == "Ingame" and 
                      model.Parent.Parent and model.Parent.Parent.Name == "Map" and 
                      model.Parent.Parent.Parent == game.Workspace
           end

           local function updateMinionESP()
               for minion, highlight in pairs(_G.MinionESPData.Highlights) do
                   if minion and minion.Parent then
                       highlight.Adornee = minion
                       highlight.Enabled = true
                   else
                       highlight.Enabled = false
                   end
               end
           end

           local function createMinionESP(minion)
               if not isMinion(minion) then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = minion.Name .. "_MinionESP"
               highlight.FillColor = Color3.fromRGB(0, 0, 255)
               highlight.FillTransparency = 0.6
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Parent = game.CoreGui
               
               _G.MinionESPData.Highlights[minion] = highlight
           end

           local function scanForMinions()
               local mapFolder = game.Workspace:FindFirstChild("Map")
               if mapFolder then
                   local ingameFolder = mapFolder:FindFirstChild("Ingame")
                   if ingameFolder then
                       local minion = ingameFolder:FindFirstChild("PizzaDeliveryRig")
                       if minion then
                           createMinionESP(minion)
                       end
                   end
               end
           end

           scanForMinions()

           local function handleDescendantAdded(descendant)
               if descendant:IsA("Model") and descendant.Name == "PizzaDeliveryRig" then
                   local parent = descendant.Parent
                   if parent and parent.Name == "Ingame" then
                       local grandParent = parent.Parent
                       if grandParent and grandParent.Name == "Map" and grandParent.Parent == game.Workspace then
                           createMinionESP(descendant)
                       end
                   end
               end
           end

           local function handleDescendantRemoving(descendant)
               if _G.MinionESPData.Highlights[descendant] then
                   _G.MinionESPData.Highlights[descendant]:Destroy()
                   _G.MinionESPData.Highlights[descendant] = nil
               end
           end

           local descendantAddedConn = game.Workspace.DescendantAdded:Connect(handleDescendantAdded)
           local descendantRemovingConn = game.Workspace.DescendantRemoving:Connect(handleDescendantRemoving)

           _G.MinionESPData.MainConnections = {
               descendantAdded = descendantAddedConn,
               descendantRemoving = descendantRemovingConn
           }

           _G.MinionESPData.UpdateLoop = game:GetService("RunService").Heartbeat:Connect(function()
               updateMinionESP()
           end)

       else
           if _G.MinionESPData then
               if _G.MinionESPData.UpdateLoop then
                   _G.MinionESPData.UpdateLoop:Disconnect()
               end

               if _G.MinionESPData.MainConnections then
                   _G.MinionESPData.MainConnections.descendantAdded:Disconnect()
                   _G.MinionESPData.MainConnections.descendantRemoving:Disconnect()
               end

               for minion, highlight in pairs(_G.MinionESPData.Highlights) do
                   highlight:Destroy()
               end

               _G.MinionESPData = nil
           end
       end
   end,
})
local AutoGenerator = {
    Enabled = false,
    Cooldown = 2.5,
    Loop = nil
}

-- –û–±—ä—è–≤–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –î–û —Ç–æ–≥–≥–ª–∞
local function ForceCompletePuzzle()
    local success, FlowGameManager = pcall(function()
        return require(game.ReplicatedStorage.Modules.Misc.FlowGameManager)
    end)
    
    if not success then
        return false
    end
    
    if FlowGameManager.activeGame and not FlowGameManager.activeGame.gameEnded then
        FlowGameManager.activeGame:EndGame(true)
        return true
    end
    
    return false
end

local function FindAndActivateGenerator()
    local IngameMapFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame")
    local SubMapFolder = IngameMapFolder and IngameMapFolder:FindFirstChild("Map")
    
    if not SubMapFolder then return false end
    
    for _, generator in ipairs(SubMapFolder:GetChildren()) do
        if generator.Name == "Generator" then
            local progress = generator:FindFirstChild("Progress")
            if progress and progress:IsA("NumberValue") and progress.Value < 100 then
                local success = pcall(function()
                    generator.Remotes.RE:FireServer()
                end)
                
                if success then
                    print("‚úÖ Generator activated, waiting for puzzle...")
                    
                    local maxWaitTime = 10
                    local startTime = tick()
                    
                    while tick() - startTime < maxWaitTime do
                        task.wait(0.1)
                        
                        if ForceCompletePuzzle() then
                            print("‚úÖ Puzzle completed automatically!")
                            return true
                        end
                    end
                    
                    print("‚ùå Puzzle didn't appear in time")
                    return false
                end
            end
        end
    end
    
    return false
end

local function StartAutoGenerator()
    if AutoGenerator.Loop then
        AutoGenerator.Loop:Disconnect()
        AutoGenerator.Loop = nil
    end
    
    AutoGenerator.Loop = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
        if not AutoGenerator.Enabled then return end
        
        if not AutoGenerator.LastCheck then
            AutoGenerator.LastCheck = tick()
        end
        
        if tick() - AutoGenerator.LastCheck >= AutoGenerator.Cooldown then
            AutoGenerator.LastCheck = tick()
            
            local success = FindAndActivateGenerator()
            
            if not success then
                print("‚ùå No available generators found")
            end
        end
    end)
end

local function StopAutoGenerator()
    if AutoGenerator.Loop then
        AutoGenerator.Loop:Disconnect()
        AutoGenerator.Loop = nil
    end
    AutoGenerator.LastCheck = nil
    print("‚ùå Auto Generator disabled")
end

-- –¢–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞–µ–º UI —ç–ª–µ–º–µ–Ω—Ç—ã –ü–û–°–õ–ï –æ–±—ä—è–≤–ª–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π
local Slider = GeneratorTab:CreateSlider({
   Name = "Auto Generator time",
   Range = {2.5, 5},
   Increment = 0.1,
   Suffix = "sec",
   CurrentValue = 2.5,
   Flag = "AutoGenTime",
   Callback = function(Value)
       AutoGenerator.Cooldown = Value
   end,
})

local Toggle = GeneratorTab:CreateToggle({
   Name = "Auto Generator",
   CurrentValue = false,
   Flag = "AutoGenToggle",
   Callback = function(Value)
       AutoGenerator.Enabled = Value
       
       if Value then
           StartAutoGenerator()
       else
           StopAutoGenerator()
       end
   end,
})

local Button = GeneratorTab:CreateButton({
   Name = "Complete Current Puzzle",
   Callback = function()
       if ForceCompletePuzzle() then
           print("‚úÖ Current puzzle completed!")
       else
           print("‚ùå No active puzzle found")
       end
   end,
})
local Aimbot = {
    Enabled = false,
    Connection = nil,
    Active = false,
    Cooldown = 3,
    Prediction = 0.5
}

local function FindPlasmaBeamButton()
    local localPlayer = game.Players.LocalPlayer
    if not localPlayer then return nil end
    
    local playerGui = localPlayer:FindFirstChild("PlayerGui")
    if not playerGui then return nil end
    
    local mainUI = playerGui:FindFirstChild("MainUI")
    if mainUI then
        local abilityContainer = mainUI:FindFirstChild("AbilityContainer")
        if abilityContainer then
            return abilityContainer:FindFirstChild("PlasmaBeam")
        end
    end
    
    return nil
end

local function GetNearestKiller()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return nil end
    
    local camera = workspace.CurrentCamera
    if not camera then return nil end
    
    local nearestKiller = nil
    local nearestDistance = math.huge
    
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") then
            local killerHRP = killer:FindFirstChild("HumanoidRootPart")
            if killerHRP then
                local distance = (camera.CFrame.Position - killerHRP.Position).Magnitude
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestKiller = killer
                end
            end
        end
    end
    
    return nearestKiller
end

local function AimAtKiller()
    local killer = GetNearestKiller()
    if not killer then return false end
    
    local camera = workspace.CurrentCamera
    if not camera then return false end
    
    local killerHRP = killer:FindFirstChild("HumanoidRootPart")
    if not killerHRP then return false end
    
    local currentCFrame = camera.CFrame
    
    -- –ü—Ä–æ—Å—Ç–æ–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è
    local predictedPosition = killerHRP.Position + killerHRP.Velocity * Aimbot.Prediction
    
    local targetCFrame = CFrame.lookAt(currentCFrame.Position, predictedPosition)
    camera.CFrame = targetCFrame
    
    return true
end

local function SetupPlasmaBeamAimbot()
    if not Aimbot.Enabled then return end
    
    local plasmaBeamButton = FindPlasmaBeamButton()
    if not plasmaBeamButton then
        task.delay(3, SetupPlasmaBeamAimbot)
        return
    end
    
    if plasmaBeamButton:IsA("TextButton") or plasmaBeamButton:IsA("ImageButton") then
        plasmaBeamButton.MouseButton1Click:Connect(function()
            if Aimbot.Enabled and not Aimbot.Active then
                Aimbot.Active = true
                
                if Aimbot.Connection then
                    Aimbot.Connection:Disconnect()
                end
                
                Aimbot.Connection = game:GetService("RunService").Heartbeat:Connect(function()
                    if not Aimbot.Active or not Aimbot.Enabled then return end
                    AimAtKiller()
                end)
                
                task.delay(Aimbot.Cooldown, function()
                    Aimbot.Active = false
                    if Aimbot.Connection then
                        Aimbot.Connection:Disconnect()
                        Aimbot.Connection = nil
                    end
                end)
            end
        end)
    end
end

local Toggle = AimbotTab:CreateToggle({
   Name = "PlasmaBeam Aimbot",
   CurrentValue = false,
   Flag = "PlasmaBeamAimbot",
   Callback = function(Value)
       Aimbot.Enabled = Value
       
       if Value then
           SetupPlasmaBeamAimbot()
       else
           if Aimbot.Connection then
               Aimbot.Connection:Disconnect()
               Aimbot.Connection = nil
           end
           Aimbot.Active = false
       end
   end,
})

local Slider = AimbotTab:CreateSlider({
   Name = "Prediction",
   Range = {0.0, 1.0},
   Increment = 0.1,
   Suffix = "sec",
   CurrentValue = 0.5,
   Flag = "AimbotPrediction",
   Callback = function(Value)
       Aimbot.Prediction = Value
   end,
})

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
    task.wait(3)
    if Aimbot.Enabled then
        SetupPlasmaBeamAimbot()
    end
end)

local ZombieESP = {
    Enabled = false,
    Highlights = {},
    Connections = {}
}

local Toggle = Tab:CreateToggle({
   Name = "1x4 Zombies Esp",
   CurrentValue = false,
   Flag = "ZombieESP",
   Callback = function(Value)
       ZombieESP.Enabled = Value
       
       if Value then
           -- –í–∫–ª—é—á–∞–µ–º ESP
           local function CreateZombieESP(zombie)
               if not zombie:IsA("Model") then return end
               if ZombieESP.Highlights[zombie] then return end
               
               local highlight = Instance.new("Highlight")
               highlight.Name = "ZombieESP"
               highlight.FillColor = Color3.fromRGB(0, 100, 255) -- –°–∏–Ω–∏–π —Ü–≤–µ—Ç
               highlight.FillTransparency = 0.7
               highlight.OutlineColor = Color3.fromRGB(255, 255, 255) -- –ë–µ–ª—ã–π –∫–æ–Ω—Ç—É—Ä
               highlight.OutlineTransparency = 0.2
               highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
               highlight.Adornee = zombie
               highlight.Parent = game.CoreGui
               
               ZombieESP.Highlights[zombie] = highlight
               
               -- –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º —É–¥–∞–ª–µ–Ω–∏–µ –∑–æ–º–±–∏
               local connection
               connection = zombie.AncestryChanged:Connect(function(_, parent)
                   if not parent then
                       if highlight then
                           highlight:Destroy()
                       end
                       ZombieESP.Highlights[zombie] = nil
                       connection:Disconnect()
                   end
               end)
           end
           
           -- –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∑–æ–º–±–∏
           local function ScanForZombies()
               local mapFolder = workspace:FindFirstChild("Map")
               if not mapFolder then return end
               
               local ingameFolder = mapFolder:FindFirstChild("Ingame")
               if not ingameFolder then return end
               
               local zombieFolder = ingameFolder:FindFirstChild("1x1x1x1Zombie")
               if not zombieFolder then return end
               
               for _, zombie in ipairs(zombieFolder:GetDescendants()) do
                   if zombie:IsA("Model") and zombie:FindFirstChild("Humanoid") then
                       CreateZombieESP(zombie)
                   end
               end
           end
           
           -- –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –Ω–æ–≤—ã—Ö –∑–æ–º–±–∏
           local function MonitorZombieFolder()
               local mapFolder = workspace:FindFirstChild("Map")
               if not mapFolder then return end
               
               local ingameFolder = mapFolder:FindFirstChild("Ingame")
               if not ingameFolder then return end
               
               local zombieFolder = ingameFolder:FindFirstChild("1x1x1x1Zombie")
               if not zombieFolder then return end
               
               ZombieESP.Connections.descendantAdded = zombieFolder.DescendantAdded:Connect(function(descendant)
                   if descendant:IsA("Model") and descendant:FindFirstChild("Humanoid") then
                       task.wait(0.1) -- –ñ–¥–µ–º –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏
                       CreateZombieESP(descendant)
                   end
               end)
               
               ZombieESP.Connections.descendantRemoving = zombieFolder.DescendantRemoving:Connect(function(descendant)
                   if ZombieESP.Highlights[descendant] then
                       ZombieESP.Highlights[descendant]:Destroy()
                       ZombieESP.Highlights[descendant] = nil
                   end
               end)
           end
           
           -- –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
           ZombieESP.Connections.updateLoop = game:GetService("RunService").Stepped:Connect(function()
               if not ZombieESP.Enabled then return end
               
               for zombie, highlight in pairs(ZombieESP.Highlights) do
                   if zombie and zombie.Parent then
                       highlight.Enabled = true
                   else
                       highlight.Enabled = false
                   end
               end
           end)
           
           -- –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
           ScanForZombies()
           MonitorZombieFolder()
           
       else
           -- –í—ã–∫–ª—é—á–∞–µ–º ESP
           for _, connection in pairs(ZombieESP.Connections) do
               connection:Disconnect()
           end
           ZombieESP.Connections = {}
           
           for _, highlight in pairs(ZombieESP.Highlights) do
               highlight:Destroy()
           end
           ZombieESP.Highlights = {}
       end
   end,
})
---------------------------------------------------------------------------
--alot of stuff exploits mostly esp and stam as ive seen end here
---------------------------------------------------------------------------
---------------------------------------------
--broekn stuff i might have to delete or fix below
------------------------------------------------------------------------

local Settings = {
    Stamina = {Enabled = false, Value = 100},
    Speed = {Enabled = false, Value = 16},
    ESP = {Players = false, Killers = true, Generators = true, Items = false},
    AutoRepair = {Enabled = false, Speed = 5, Instant = false}
}

local function ManageStamina()
while Settings.Stamina.Enabled do
task.wait(0.5)
local char = game.Players.LocalPlayer.Character
if char and char:FindFirstChild("Stamina") then
char.Stamina.Value = Settings.Stamina.Value
end
end
end

local function UpdateSpeed()
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Settings.Speed.Enabled and Settings.Speed.Value or 26.5
end

local Tab = MainWindow:NewTab("Main")
local MainSection = Tab:NewSection("Character")

MainSection:NewToggle("Infinite Stamina", "", function(state)
    Settings.Stamina.Enabled = state
    ManageStamina()
end)

MainSection:NewSlider("Speed", "", 50, 16, function(value)
    Settings.Speed.Value = value
    UpdateSpeed()
end)

MainSection:NewToggle("Enable Speed", "", function(state)
    Settings.Speed.Enabled = state
    UpdateSpeed()
end)

local Tab = MainWindow:NewTab("ESP")
local ESPSection = Tab:NewSection("Settings")

ESPSection:NewToggle("Players", "", function(state)
    Settings.ESP.Players = state
end)

ESPSection:NewToggle("Killers", "", function(state)
    Settings.ESP.Killers = state
end)

local AutoTab = MainWindow:NewTab("Automation")
local AutoSection = AutoTab:NewSection("Generators")

AutoSection:NewToggle("Auto-Repair", "", function(state)
    Settings.AutoRepair.Enabled = state
end)

AutoSection:NewSlider("Repair Speed", "", 20, 3, function(value)
    Settings.AutoRepair.Speed = value
end)

AutoSection:NewToggle("Instant Repair", "", function(state)
    Settings.AutoRepair.Instant = state
end)

game:GetService("StarterGui"):SetCore("SendNotification",{
    Title = "Loader",
    Text = "Ready",
    Duration = 3
})


------------------------------------------------------------------------
--end of that stuff i might have to delate or fix idk  lOL
-----------------------------------------------
------------------------------------------------------------------------
--goodeieever start  lOL
-----------------------------------------------

local Settings = {
    Stamina = {Enabled = false, Value = 100},
    Speed = {Enabled = false, Value = 16},
    ESP = {Players = false, Killers = true, Generators = true, Items = false},
    AutoRepair = {Enabled = false, Speed = 5, Instant = false}
}

local function ManageStamina()
while Settings.Stamina.Enabled do
task.wait(0.5)
local char = game.Players.LocalPlayer.Character
if char and char:FindFirstChild("Stamina") then
char.Stamina.Value = Settings.Stamina.Value
end
end
end

local function UpdateSpeed()
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = Settings.Speed.Enabled and Settings.Speed.Value or 26.5
end



MainSection:NewToggle("Infinite Stamina", "", function(state)
    Settings.Stamina.Enabled = state
    ManageStamina()
end)

MainSection:NewSlider("Speed", "", 50, 16, function(value)
    Settings.Speed.Value = value
    UpdateSpeed()
end)

MainSection:NewToggle("Enable Speed", "", function(state)
    Settings.Speed.Enabled = state
    UpdateSpeed()
end)

local Tab = MainWindow:NewTab("ESP")
local ESPSection = Tab:NewSection("Settings")

ESPSection:NewToggle("Players", "", function(state)
    Settings.ESP.Players = state
end)

ESPSection:NewToggle("Killers", "", function(state)
    Settings.ESP.Killers = state
end)

local AutoTab = MainWindow:NewTab("Automation")
local AutoSection = AutoTab:NewSection("Generators")

AutoSection:NewToggle("Auto-Repair", "", function(state)
    Settings.AutoRepair.Enabled = state
end)

AutoSection:NewSlider("Repair Speed", "", 20, 3, function(value)
    Settings.AutoRepair.Speed = value
end)

AutoSection:NewToggle("Instant Repair", "", function(state)
    Settings.AutoRepair.Instant = state
end)

game:GetService("StarterGui"):SetCore("SendNotification",{
    Title = "Loader",
    Text = "Ready",
    Duration = 3
})




------------------------------------------------------------------------
--SO LONG AUTO BLOCK start  lOL
-----------------------------------------------



local Button = Tab:CreateButton({
   Name = "Button Example",
   Callback = function()
   -- The function that takes place when the button is pressed
   loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/ebdc21137d5ee95d59a4b18df14f73df9b2349a3/autoblock1v1'))()
      -- The function that takes place when the button is pressed
   end,
})



local lastReplaceTime = {
    block = 0,
    punch = 0,
    charge = 0,
}
function happhapp()
loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/Moreautoblocl%3F'))()
end
happhapp()
-- Auto block + punch detection loop
RunService.RenderStepped:Connect(function()
    local gui = PlayerGui:FindFirstChild("MainUI")
    local punchBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Punch")
    local charges = punchBtn and punchBtn:FindFirstChild("Charges")
    local blockBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Block")
    local cooldown = blockBtn and blockBtn:FindFirstChild("CooldownTime")

    local myChar = lp.Character
    if not myChar then return end
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    Humanoid = myChar:FindFirstChildOfClass("Humanoid")
        -- Auto Block: Trigger block if a valid animation is played by a killer
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= lp and plr.Character then
            local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
            local hum = plr.Character:FindFirstChildOfClass("Humanoid")
            local animTracks = hum and hum:FindFirstChildOfClass("Animator") and hum:FindFirstChildOfClass("Animator"):GetPlayingAnimationTracks()

            if hrp and myRoot and (hrp.Position - myRoot.Position).Magnitude <= detectionRange then
                for _, track in ipairs(animTracks or {}) do
                    local id = tostring(track.Animation.AnimationId):match("%d+")
                    if table.find(autoBlockTriggerAnims, id) then
                        if autoBlockOn and (hrp.Position - myRoot.Position).Magnitude <= detectionRange then
                            if isFacing(myRoot, hrp) then
                                if cooldown and cooldown.Text == "" then
                                    fireRemoteBlock()
                                end
                                if doubleblocktech == true and charges and charges.Text == "1" then
                                    fireRemotePunch()
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    -- Detect if player is playing a block animation, and blockTP is enabled

    -- Predictive Auto Block: Check killer range and time
    if predictiveBlockOn and tick() > predictiveCooldown then
        local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
        local myChar = lp.Character
        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local myHum = myChar and myChar:FindFirstChild("Humanoid")

        if killersFolder and myHRP and myHum then
            local killerInRange = false

            for _, killer in ipairs(killersFolder:GetChildren()) do
                local hrp = killer:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local dist = (myHRP.Position - hrp.Position).Magnitude
                    if dist <= detectionRange then
                        killerInRange = true
                        break
                    end
                end
            end

            -- Handle killer entering range
            if killerInRange then
                if not killerInRangeSince then
                    killerInRangeSince = tick()  -- Start the timer when the killer enters the range
                elseif tick() - killerInRangeSince >= edgeKillerDelay then
                    -- Block if the killer has stayed in range long enough
                    fireRemoteBlock()
                    predictiveCooldown = tick() + 2  -- Set cooldown to avoid blocking too quickly again
                    killerInRangeSince = nil  -- Reset the timer
                end
            else
                killerInRangeSince = nil  -- Reset timer if the killer leaves range
            end
        end
    end


    local myChar = lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    -- Auto Punch
    if autoPunchOn then
        if charges and charges.Text == "1" then
            
            for _, name in ipairs(killerNames) do
                local killer = workspace:FindFirstChild("Players")
                    and workspace.Players:FindFirstChild("Killers")
                    and workspace.Players.Killers:FindFirstChild(name)
                if killer and killer:FindFirstChild("HumanoidRootPart") then
                    local root = killer.HumanoidRootPart
                    if root and myRoot and (root.Position - myRoot.Position).Magnitude <= 10 then

                        -- Trigger punch GUI button
                        fireGuiPunch()

                        -- Fling Punch: Constant TP 2 studs in front of killer for 1 second
                        if flingPunchOn then
                            hiddenfling = true
                            local targetHRP = root
                            task.spawn(function()
                                local start = tick()
                                while tick() - start < 1 do
                                    if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and targetHRP and targetHRP.Parent then
                                        local frontPos = targetHRP.Position + (targetHRP.CFrame.LookVector * 2)
                                        lp.Character.HumanoidRootPart.CFrame = CFrame.new(frontPos, targetHRP.Position)
                                    end
                                    task.wait()
                                end
                                hiddenfling = false
                            end)
                        end

                        -- Play custom punch animation if enabled
                        if customPunchEnabled and customPunchAnimId ~= "" then
                            playCustomAnim(customPunchAnimId, true)
                        end

                        break -- Only punch one killer per frame
                    end
                end
            end
        end
    end
    -- === Message-When-Punching: send once per animation start ===
    do
        local myChar = lp.Character
        local hum = myChar and myChar:FindFirstChildOfClass("Humanoid")
        local animator = cachedAnimator
        local currentPlaying = {} -- map animId -> true for tracks playing this frame
        if not animator then
            refreshAnimator()
            animator = cachedAnimator
        end
        if animator then
            local ok, tracks = pcall(function() return animator:GetPlayingAnimationTracks() end)
            if ok and tracks then
                for _, track in ipairs(tracks) do
                    local animId
                    pcall(function() animId = tostring(track.Animation and track.Animation.AnimationId or ""):match("%d+") end)
                    if animId and table.find(punchAnimIds, animId) then
                        currentPlaying[animId] = true
    
                        -- if it wasn't playing last frame, it's a newly-started punch animation
                        if not _punchPrevPlaying[animId] then
                            if messageWhenAutoPunchOn and messageWhenAutoPunch and tostring(messageWhenAutoPunch):match("%S") and (tick() - _lastPunchMessageTime) > MESSAGE_PUNCH_COOLDOWN then
                                pcall(function() sendChatMessage(messageWhenAutoPunch) end)
                                _lastPunchMessageTime = tick()
                            end
                        end
                    end
                end
            end
        end

        -- replace prev state with current state (garbage-collected)
        _punchPrevPlaying = currentPlaying
    end

    do
        local myChar = lp.Character
        local hum = myChar and myChar:FindFirstChildOfClass("Humanoid")
        local animator = cachedAnimator
        local currentPlaying = {} -- map animId -> true for tracks playing this frame
        if not animator then
            refreshAnimator()
            animator = cachedAnimator
        end
        if animator then
            local ok, tracks = pcall(function() return animator:GetPlayingAnimationTracks() end)
            if ok and tracks then
                for _, track in ipairs(tracks) do
                    local animId
                    pcall(function() animId = tostring(track.Animation and track.Animation.AnimationId or ""):match("%d+") end)
                    if animId and table.find(blockAnimIds, animId) then
                        currentPlaying[animId] = true
    
                        -- if it wasn't playing last frame, it's a newly-started punch animation
                        if not _blockPrevPlaying[animId] then
                            if messageWhenAutoBlockOn and messageWhenAutoBlock and tostring(messageWhenAutoBlock):match("%S") and (tick() - _lastBlockMessageTime) > MESSAGE_BLOCK_COOLDOWN then
                                pcall(function() sendChatMessage(messageWhenAutoBlock) end)
                                _lastBlockMessageTime = tick()
                            end
                        end
                    end
                end
            end
        end

        -- replace prev state with current state (garbage-collected)
        _blockPrevPlaying = currentPlaying
    end

    -- === end message-when-punching ===
    if aimPunch then
        if not cachedAnimator then
            refreshAnimator()
        end
        local animator = cachedAnimator
        if animator and myRoot and myChar then
            for _, name in ipairs(killerNames) do
                local killer = workspace:FindFirstChild("Players")
                    and workspace.Players:FindFirstChild("Killers")
                    and workspace.Players.Killers:FindFirstChild(name)
                if killer and killer:FindFirstChild("HumanoidRootPart") then
                    local root = killer.HumanoidRootPart

                    for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                        -- guard: want only punch tracks (vanilla or custom)
                        local animId = tostring(track.Animation.AnimationId):match("%d+")
                        if table.find(punchAnimIds, animId) then

                            -- Avoid retriggering for the same AnimationTrack within cooldown
                            local last = lastAimTrigger[track]
                            if last and tick() - last < AIM_COOLDOWN then
                                -- already triggered recently for this track -> skip
                            else
                                -- Only trigger when the track is just starting (helps avoid mid/late triggers)
                                local timePos = 0
                                pcall(function() timePos = track.TimePosition or 0 end) -- safe read
                                if timePos <= 0.1 then
                                    -- Lock it so we don't retrigger
                                    lastAimTrigger[track] = tick()

                                    -- Disable autoroate once and aim for AIM_WINDOW seconds
                                    local humanoid = myChar:FindFirstChild("Humanoid")
                                    if humanoid then
                                        humanoid.AutoRotate = false
                                    end

                                    task.spawn(function()
                                        local start = tick()
                                        while tick() - start < AIM_WINDOW do
                                            if myRoot and root and root.Parent then
                                                local predictedPos = root.Position + (root.CFrame.LookVector * predictionValue)
                                                myRoot.CFrame = CFrame.lookAt(myRoot.Position, predictedPos)
                                            end
                                            task.wait()
                                        end
                                        -- restore
                                        if humanoid then
                                            humanoid.AutoRotate = true
                                        end

                                        -- cleanup: allow retrigger later
                                        task.delay(AIM_COOLDOWN - AIM_WINDOW, function()
                                            lastAimTrigger[track] = nil
                                        end)
                                    end)
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end)





------------------------------------------------------------------------
--SO LONG END OF AUTO BLOCK end  lOL
-----------------------------------------------




loadstring(game:HttpGet('https://raw.githubusercontent.com/ParallaxCube/Final-ShockCatStudio-script/refs/heads/main/%3Fan%20extra%20gui'))()







-------------------------------------------------------------------------------------------------------
--end of a whole other code im so done fr
-------------------------------------------------------------------------------------------------------


Rayfield:LoadConfiguration()
meep()
